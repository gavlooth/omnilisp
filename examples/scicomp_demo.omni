; ===========================================
; Scientific Computing Demo
; ===========================================
;
; Demonstrates the SciComp modules for:
; - Vector and matrix operations (BLAS)
; - Linear algebra (LAPACK)
; - Neural networks (LibTorch)
;
; Run with: ./omnilisp examples/scicomp_demo.omni

(import SciComp.BLAS)
(import SciComp.Linalg)
; (import SciComp.Torch)  ; Uncomment if LibTorch is installed

(print "\n=== Scientific Computing Demo ===\n\n")

; ===========================================
; Demo 1: Basic Vector Operations
; ===========================================

(print "--- Demo 1: Vector Operations ---\n")

(let ((x (vec-from-list '(1.0 2.0 3.0 4.0 5.0)))
      (y (vec-from-list '(5.0 4.0 3.0 2.0 1.0))))

  (print "x = ")
  (vec-print x)
  (print "\n")

  (print "y = ")
  (vec-print y)
  (print "\n")

  (print "x . y = " (vec-dot x y) "\n")
  (print "||x||_2 = " (vec-norm x) "\n")

  (let ((z (vec-add x y)))
    (print "x + y = ")
    (vec-print z)
    (print "\n")
    (vec-free! z))

  (let ((w (vec-scale 2.0 x)))
    (print "2*x = ")
    (vec-print w)
    (print "\n")
    (vec-free! w))

  (vec-free! x)
  (vec-free! y))

; ===========================================
; Demo 2: Matrix Operations
; ===========================================

(print "\n--- Demo 2: Matrix Operations ---\n")

(let ((A (mat-from-lists '((1.0 2.0 3.0)
                           (4.0 5.0 6.0)
                           (7.0 8.0 9.0))))
      (B (mat-from-lists '((9.0 8.0 7.0)
                           (6.0 5.0 4.0)
                           (3.0 2.0 1.0)))))

  (print "Matrix A:\n")
  (mat-print A)

  (print "\nMatrix B:\n")
  (mat-print B)

  (let ((C (mat-mul A B)))
    (print "\nA * B:\n")
    (mat-print C)
    (mat-free! C))

  (let ((At (mat-transpose A)))
    (print "\nA^T:\n")
    (mat-print At)
    (mat-free! At))

  (mat-free! A)
  (mat-free! B))

; ===========================================
; Demo 3: Solving Linear Systems
; ===========================================

(print "\n--- Demo 3: Linear System Solver ---\n")

; Solve: 2x + y = 5
;        x + 3y = 7

(let ((A (mat-from-lists '((2.0 1.0)
                           (1.0 3.0))))
      (b (vec-from-list '(5.0 7.0))))

  (print "System: A*x = b\n")
  (print "A = \n")
  (mat-print A)
  (print "b = ")
  (vec-print b)
  (print "\n")

  (let ((x (solve A b)))
    (print "\nSolution x = ")
    (vec-print x)
    (print "\n")

    ; Verify: A*x should equal b
    (let ((Ax (mat-vec-mul A x)))
      (print "Verification A*x = ")
      (vec-print Ax)
      (print "\n")
      (vec-free! Ax))

    (vec-free! x))

  (mat-free! A)
  (vec-free! b))

; ===========================================
; Demo 4: Matrix Decompositions
; ===========================================

(print "\n--- Demo 4: Matrix Decompositions ---\n")

; LU Decomposition
(print "LU Decomposition:\n")
(let ((A (mat-from-lists '((4.0 3.0)
                           (6.0 3.0)))))
  (print "A =\n")
  (mat-print A)

  (let ((result (lu A)))
    (print "\nL =\n")
    (mat-print (LU-L result))
    (print "\nU =\n")
    (mat-print (LU-U result))

    (mat-free! (LU-L result))
    (mat-free! (LU-U result))
    (vec-free! (LU-perm result)))

  (mat-free! A))

; Cholesky Decomposition
(print "\nCholesky Decomposition:\n")
(let ((A (mat-from-lists '((4.0 2.0)
                           (2.0 5.0)))))  ; Symmetric positive definite
  (print "A (SPD) =\n")
  (mat-print A)

  (let ((L (cholesky A)))
    (print "\nL (A = L*L^T) =\n")
    (mat-print L)
    (mat-free! L))

  (mat-free! A))

; QR Decomposition
(print "\nQR Decomposition:\n")
(let ((A (mat-from-lists '((12.0 -51.0 4.0)
                           (6.0 167.0 -68.0)
                           (-4.0 24.0 -41.0)))))
  (print "A =\n")
  (mat-print A)

  (let ((result (qr A)))
    (print "\nQ =\n")
    (mat-print (QR-Q result))
    (print "\nR =\n")
    (mat-print (QR-R result))

    (mat-free! (QR-Q result))
    (mat-free! (QR-R result)))

  (mat-free! A))

; ===========================================
; Demo 5: Least Squares Regression
; ===========================================

(print "\n--- Demo 5: Least Squares Regression ---\n")

; Fit y = a + b*x to data points
; x: 1, 2, 3, 4, 5
; y: 2.1, 3.9, 6.1, 7.9, 10.2

(let ((X (mat-from-lists '((1.0 1.0)
                           (1.0 2.0)
                           (1.0 3.0)
                           (1.0 4.0)
                           (1.0 5.0))))
      (y (vec-from-list '(2.1 3.9 6.1 7.9 10.2))))

  (print "Data points:\n")
  (print "x: 1, 2, 3, 4, 5\n")
  (print "y: 2.1, 3.9, 6.1, 7.9, 10.2\n")

  (let ((beta (lstsq X y)))
    (print "\nFitted line: y = " (vec-get beta 0) " + " (vec-get beta 1) " * x\n")
    (print "(Expected: y ≈ 0.0 + 2.0 * x)\n")
    (vec-free! beta))

  (mat-free! X)
  (vec-free! y))

; ===========================================
; Demo 6: Matrix Properties
; ===========================================

(print "\n--- Demo 6: Matrix Properties ---\n")

(let ((A (mat-from-lists '((1.0 2.0 3.0)
                           (4.0 5.0 6.0)
                           (7.0 8.0 10.0)))))  ; Non-singular (det ≠ 0)

  (print "A =\n")
  (mat-print A)

  (print "\ndet(A) = " (det A) "\n")
  (print "trace(A) = " (trace A) "\n")
  (print "||A||_F = " (norm-fro A) "\n")
  (print "||A||_1 = " (norm-1 A) "\n")
  (print "||A||_inf = " (norm-inf A) "\n")

  (let ((Ainv (inv A)))
    (print "\nA^-1 =\n")
    (mat-print Ainv)

    ; Verify: A * A^-1 = I
    (let ((I (mat-mul A Ainv)))
      (print "\nA * A^-1 (should be I):\n")
      (mat-print I)
      (mat-free! I))

    (mat-free! Ainv))

  (mat-free! A))

; ===========================================
; Demo 7: Using with-mat for Automatic Cleanup
; ===========================================

(print "\n--- Demo 7: Scoped Resource Management ---\n")

(let ((result
       (with-mat (A (mat-from-lists '((1.0 2.0) (3.0 4.0))))
         (with-mat (B (mat-from-lists '((5.0 6.0) (7.0 8.0))))
           (with-mat (C (mat-mul A B))
             ; Compute trace of A*B
             (trace C))))))
  (print "trace(A*B) = " result "\n")
  (print "(A, B, C are automatically freed)\n"))

; ===========================================
; Demo 8: LibTorch Neural Network (if available)
; ===========================================

; Uncomment this section if LibTorch is installed:

; (print "\n--- Demo 8: Neural Network (LibTorch) ---\n")
;
; ; Check if CUDA is available
; (print "CUDA available: " (if (cuda-available?) "Yes" "No") "\n")
;
; ; Create random tensors
; (let ((x (randn '(32 10)))   ; Batch of 32, 10 features
;       (W (randn '(10 5)))    ; Weight matrix
;       (b (randn '(5))))      ; Bias vector
;
;   (print "Input shape: " (shape x) "\n")
;   (print "Weight shape: " (shape W) "\n")
;
;   ; Forward pass: y = relu(x @ W + b)
;   (let ((xW (t@ x W)))
;     (let ((xW-b (t+ xW (unsqueeze b 0))))
;       (let ((y (t-relu xW-b)))
;         (print "Output shape: " (shape y) "\n")
;         (print "Output mean: " (item (t-mean y)) "\n"))))
;
;   ; Enable gradients for backprop
;   (requires-grad! W)
;   (requires-grad! b)
;
;   ; Create target
;   (let ((target (randn '(32 5))))
;
;     ; Forward pass
;     (let ((pred (t-relu (t+ (t@ x W) (unsqueeze b 0)))))
;
;       ; Compute loss
;       (let ((loss (mse-loss pred target)))
;         (print "MSE Loss: " (item loss) "\n")
;
;         ; Backward pass
;         (backward! loss)
;
;         (print "Gradient computed for W: "
;                (if (requires-grad? W) "Yes" "No") "\n")))))

(print "\n=== Demo Complete ===\n")
