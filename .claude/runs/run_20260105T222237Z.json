{"type":"result","subtype":"success","is_error":false,"duration_ms":229754,"duration_api_ms":271689,"num_turns":21,"result":"---\n\n## Pre-check (Buglog)\n\nI have read `buglog.md` and confirmed the issue I found is **not already recorded**:\n- BUG-0001: Component merge integer overflow\n- BUG-0002: Pool bounds staleness after growth\n\nThe issue I found (continuation reference counting leak in `cont_invoke`) is a different bug in a different module (`continuation.c` vs `component.c`/`handle.c`).\n\n---\n\n## Issue\n\n**Summary**: Memory leak in `cont_invoke()` - the old `tl_current_frame` is not released when installing a new continuation\n\n**Why it violates architecture/invariants**:\n- **Memory management invariant**: All allocated resources must be properly released when no longer needed\n- **Reference counting invariant**: When replacing a reference, the old reference must be decremented\n- In `continuation.c:305`, `tl_current_frame = frames_to_install;` overwrites the thread-local current frame without releasing the reference to the previous frame chain\n- This causes the entire previous frame chain to leak every time a continuation is invoked\n\n**Evidence (code references)**:\n- `continuation.c:244-309` - `cont_invoke()` function\n- Line 280: `frame_inc_ref(frames_to_install);` - New reference is acquired\n- Line 305: `tl_current_frame = frames_to_install;` - Old value is overwritten without `frame_dec_ref()`\n- Compare with `cont_set_current()` at line 1231-1235 which correctly handles the transition:\n  ```c\n  void cont_set_current(Frame* f) {\n      if (tl_current_frame) frame_dec_ref(tl_current_frame);\n      tl_current_frame = f;\n      if (f) frame_inc_ref(f);\n  }\n  ```\n\n---\n\n## Failing Test\n\n**Test name**: `test_continuation_refcount_leak.c`\n\n**Files to add**:\n- `/home/heefoo/Documents/code/OmniLisp/runtime/tests/test_continuation_refcount_leak.c`\n\n**Code**: (Already written and demonstrates the bug - test output shows \"FAIL: Memory leak detected!\")\n\nThe test:\n1. Creates a frame chain with 2 frames\n2. Captures a continuation\n3. Invokes the continuation using the buggy code\n4. Verifies that 3 frames are leaked (the original frame chain was never freed)\n5. Compares with a fixed version that properly decrements the old `tl_current_frame`\n\n---\n\n## Fix Proposal (do not implement unless asked)\n\n**Minimal change**:\nIn `continuation.c:304-305`, replace:\n```c\n/* Install new continuation */\ntl_current_frame = frames_to_install;\n```\n\nWith:\n```c\n/* Install new continuation */\nFrame* old = tl_current_frame;\ntl_current_frame = frames_to_install;\nframe_dec_ref(old);\n```\n\nThis matches the pattern used in `cont_set_current()` (lines 1231-1235) and ensures the old frame chain is properly released.\n\n**Why it resolves the invariant violation**:\n- The old `tl_current_frame` had a reference that was never released\n- By calling `frame_dec_ref(old)` after replacing the reference, we properly balance the reference count\n- This prevents memory leaks of frame chains every time a continuation is invoked\n\n---\n\n## Tooling Used (for discovery)\n\n- **Manual code review** - Reading continuation.c to understand the continuation management\n- **Compilation and execution** - Built and ran the test with `gcc -o runtime/tests/test_continuation_refcount_leak runtime/tests/test_continuation_refcount_leak.c -I runtime/include -lpthread`\n- **For future validation**:\n  - Valgrind would detect the memory leak: `valgrind --leak-check=full --show-leak-kinds=all ./runtime/tests/test_continuation_refcount_leak`\n  - ASan could also detect: `gcc -fsanitize=address -g runtime/tests/test_continuation_refcount_leak.c -o test_leak`\n\n---\n\n## Buglog Update\n\n```markdown\n### BUG-0003: Continuation Invoke Memory Leak\n- **Date**: 2026-01-06\n- **Area**: `runtime/src/memory/continuation.c` - `cont_invoke()`\n- **Invariant violated**: Memory management - reference counting invariant (replace requires decrement of old reference)\n- **Symptom**: When `cont_invoke()` installs a new continuation by assigning `tl_current_frame = frames_to_install`, the old `tl_current_frame` value is overwritten without calling `frame_dec_ref()`. This causes the entire previous frame chain to leak every time a continuation is invoked. In a long-running program that uses continuations frequently (e.g., generators, coroutines, async/await), this can accumulate significant memory leaks.\n- **Root cause (confirmed)**: In `continuation.c:304-305`, the code directly assigns `tl_current_frame = frames_to_install` without first saving and decrementing the old value. This is inconsistent with the pattern used elsewhere in the same file, such as `cont_set_current()` at lines 1231-1235 which correctly handles the transition:\n  ```c\n  void cont_set_current(Frame* f) {\n      if (tl_current_frame) frame_dec_ref(tl_current_frame);\n      tl_current_frame = f;\n      if (f) frame_inc_ref(f);\n  }\n  ```\n  The bug was introduced because `cont_invoke()` uses `frame_inc_ref(frames_to_install)` at line 280 (or uses cloned frames), but forgets to release the reference to the frame being replaced.\n- **Evidence (code references)**:\n  - `continuation.c:280` - `frame_inc_ref(frames_to_install);` acquires new reference\n  - `continuation.c:305` - `tl_current_frame = frames_to_install;` overwrites without cleanup\n  - `continuation.c:1231-1235` - `cont_set_current()` shows correct pattern\n- **Repro test**: `runtime/tests/test_continuation_refcount_leak.c`\n  - Creates a frame chain with 2 frames (refcount 1 each, with parent reference)\n  - Captures a continuation\n  - Invokes the continuation\n  - Verifies that 3 frames leak (the entire previous chain)\n  - Compares with a fixed version that shows no leaks\n- **Tool signals**:\n  - Test demonstrates memory leak by tracking alloc/free counts\n  - Would be detected by Valgrind with `--leak-check=full`\n  - Would be detected by ASan with `-fsanitize=address`\n- **Status**: new\n- **Notes**:\n  - This is distinct from all existing buglog entries (BUG-0001: component merge overflow, BUG-0002: pool bounds staleness)\n  - The fix is straightforward (3 lines added), similar to the existing `cont_set_current()` pattern\n  - This bug affects all continuation-based features: generators (`generator_next`), delimited continuations (`cont_invoke`), promises, and fiber-based coroutines\n  - In high-frequency scenarios (e.g., tight loops using generators), the leak could be substantial\n```","session_id":"f6b9731f-8493-416d-9ac5-c8bdaf3303b9","total_cost_usd":0.7896309,"usage":{"input_tokens":85796,"cache_creation_input_tokens":0,"cache_read_input_tokens":1187200,"output_tokens":5800,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"modelUsage":{"glm-4.7":{"inputTokens":87703,"outputTokens":6033,"cacheReadInputTokens":1187840,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.7099559999999999,"contextWindow":200000},"glm-4.5-air":{"inputTokens":2988,"outputTokens":4605,"cacheReadInputTokens":5453,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.07967489999999998,"contextWindow":200000}},"permission_denials":[],"uuid":"55e74b09-5bff-4a7f-bdd3-5ef4b7e51747"}
