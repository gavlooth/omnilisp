{"type":"result","subtype":"success","is_error":false,"duration_ms":375571,"duration_api_ms":424381,"num_turns":19,"result":"---\n\n### Pre-check (Buglog)\n- I read `buglog.md` - it contains BUG-0001 through BUG-0005\n- This issue is NEW and NOT a duplicate:\n  - BUG-0001: Component merge integer overflow (different area)\n  - BUG-0002: Pool bounds staleness (different area)\n  - BUG-0003: Frame clone jmpbuf unsafe memcpy (different area)\n  - BUG-0004: SCC refcount underflow (different issue - that was about `release_scc()` decrementing refcount)\n  - BUG-0005: Symmetric pool freelist type-punning (different area)\n\n---\n\n### Issue\n- **Summary**: SCC Node Hashmap Put Failure Leak and Duplicate Node Creation\n\n- **Why it violates architecture/invariants**: \n\n  The `get_or_create_node()` function in `scc.c` maintains a critical invariant: every SCCNode in the `node_map` linked list should also be in the `node_lookup` hashmap for O(1) lookup. This invariant is violated when `hashmap_put()` fails.\n\n  Specifically:\n  1. The node is added to `node_map` linked list BEFORE calling `hashmap_put()` (line 117-119)\n  2. If `hashmap_put()` fails (malloc failure for HashEntry), the node is orphaned - it exists in the linked list but NOT in the hashmap\n  3. The function still returns the node as if it were properly registered\n  4. Future calls to `get_node()` won't find it (because `hashmap_get` returns NULL)\n  5. Another call to `get_or_create_node()` for the same object creates a SECOND node, violating the one-node-per-object invariant\n\n- **Evidence (code references)**:\n  - `scc.c:106-125` - `get_or_create_node()` function\n  - `scc.c:111` - malloc for SCCNode\n  - `scc.c:117-119` - Node added to `node_map` linked list BEFORE hashmap insertion\n  - `scc.c:122` - `hashmap_put()` called without checking for failure\n  - `hashmap.c:134-138` - `hashmap_put()` can fail silently (sets `had_alloc_failure = 1` and returns)\n  - `hashmap.h:21` - `had_alloc_failure` flag exists but is never checked by `get_or_create_node()`\n\n---\n\n### Failing Test\n- **Test name**: `test_scc_hashmap_put_failure`\n- **Files to add/modify**: \n  - Added: `runtime/tests/test_scc_hashmap_put_failure.c`\n\n- **Code**: (created at `/home/heefoo/Documents/code/OmniLisp/runtime/tests/test_scc_hashmap_put_failure.c`)\n\n  Test output confirms:\n  ```\n  *** BUG CONFIRMED ***\n  Node exists in node_map but NOT in node_lookup hashmap!\n  \n  *** DUPLICATE NODE BUG CONFIRMED ***\n  Now there are TWO nodes for the same object!\n  node1 = 0x... (orphaned, in linked list only)\n  node2 = 0x... (properly registered)\n  \n  Total nodes in linked list: 2 (should be 1)\n  Total nodes in hashmap: 1 (should be 1)\n  ```\n\n---\n\n### Fix Proposal (do not implement unless asked)\n\n- **Minimal change**:\n  \n  In `scc.c:106-125`, modify `get_or_create_node()` to check if `hashmap_put()` succeeded:\n\n  ```c\n  static SCCNode* get_or_create_node(SCCRegistry* reg, Obj* obj) {\n      if (!reg || !obj) return NULL;\n      SCCNode* existing = get_node(reg, obj);\n      if (existing) return existing;\n\n      SCCNode* n = malloc(sizeof(SCCNode));\n      if (!n) return NULL;\n      n->id = -1;\n      n->lowlink = -1;\n      n->on_stack = 0;\n      n->obj = obj;\n      n->next = reg->node_map;\n      n->stack_next = NULL;\n\n      /* Try to add to hash map */\n      hashmap_put(reg->node_lookup, obj, n);\n\n      /* Check if insertion failed */\n      if (hashmap_had_alloc_failure(reg->node_lookup)) {\n          /* Rollback: remove from node_map and free */\n          reg->node_map = n->next;\n          free(n);\n          return NULL;\n      }\n\n      reg->node_map = n;\n      return n;\n  }\n  ```\n\n  Note: The order of operations needs to be adjusted - add to hashmap BEFORE adding to linked list, so rollback is simpler.\n\n- **Why it resolves the invariant violation**:\n  - Prevents orphaned nodes from being added to `node_map` without being in `node_lookup`\n  - Returns NULL on failure, allowing caller to handle the error\n  - Maintains the one-node-per-object invariant\n  - Prevents duplicate node creation and memory leaks\n\n---\n\n### Tooling Used (for discovery)\n\n- **Tools used**:\n  - Manual code review and exploration using Task tool with Explore agent\n  - GCC with `-Wall -Wextra` for compilation warnings\n  - ASan (`-fsanitize=address`) for memory safety checking (detected use-after-free in test cleanup)\n\n- **Commands run**:\n  ```bash\n  # Compile and run test\n  gcc -o runtime/tests/test_scc_hashmap_put_failure runtime/tests/test_scc_hashmap_put_failure.c -Wall -Wextra && ./runtime/tests/test_scc_hashmap_put_failure\n  \n  # With ASan\n  gcc -o runtime/tests/test_scc_hashmap_put_failure runtime/tests/test_scc_hashmap_put_failure.c -Wall -Wextra -g -fsanitize=address && ./runtime/tests/test_scc_hashmap_put_failure\n  ```\n\n- **Recommended additional tools**:\n  - Valgrind memcheck for memory leak detection\n  - Clang-tidy static analysis for error handling issues\n  - Fuzzing with AFL++ to explore allocation failure paths\n\n---\n\n### Buglog Update\n\n**Entry to append to `buglog.md`:**\n\n```markdown\n### BUG-0006: SCC Node Hashmap Put Failure Leak\n- **Date**: 2026-01-06\n- **Area**: `runtime/src/memory/scc.c` - `get_or_create_node()`\n- **Invariant violated**: Data structure consistency - every SCCNode in `node_map` linked list must also be in `node_lookup` hashmap for O(1) lookup\n- **Symptom**: When `hashmap_put()` fails due to malloc failure for HashEntry, the node is still added to `node_map` linked list and returned to the caller, but it is NOT in the hashmap. This creates an \"orphaned\" node that:\n  1. Cannot be found by subsequent `get_node()` calls\n  2. Causes duplicate node creation if `get_or_create_node()` is called again for the same object\n  3. Breaks the invariant that `node_map` and `node_lookup` stay synchronized\n- **Root cause (confirmed)**: In `scc.c:106-125`, the `get_or_create_node()` function:\n  ```c\n  SCCNode* n = malloc(sizeof(SCCNode));\n  /* ... initialize node ... */\n  n->next = reg->node_map;\n  reg->node_map = n;  /* Added to linked list FIRST */\n\n  hashmap_put(reg->node_lookup, obj, n);  /* Can fail silently! */\n  return n;  /* Returns node even if put failed */\n  ```\n  The node is added to `node_map` at line 119 BEFORE calling `hashmap_put()` at line 122. If `hashmap_put()` fails (malloc failure for HashEntry), it sets `had_alloc_failure=1` and returns without inserting the entry (hashmap.c:134-138). The function still returns the node, which is now in `node_map` but not in `node_lookup`.\n\n  On the next call to `get_or_create_node()` for the same object:\n  1. `get_node()` returns NULL (not in hashmap)\n  2. A SECOND node is created for the same object\n  3. Now `node_map` has 2 nodes but `node_lookup` has only 1 entry\n- **Evidence (code references)**:\n  - `scc.c:106-125` - `get_or_create_node()` with missing error check\n  - `scc.c:117-119` - Node added to linked list before hashmap insertion\n  - `scc.c:122` - `hashmap_put()` called without checking `had_alloc_failure`\n  - `hashmap.c:134-138` - `hashmap_put()` failure path (silent failure with flag)\n  - `hashmap.h:21` - `had_alloc_failure` flag exists but is never checked\n- **Repro test**: `runtime/tests/test_scc_hashmap_put_failure.c`\n  - Forces `hashmap_put()` to fail by mocking allocation failure\n  - Verifies node is in `node_map` but NOT in `node_lookup` (orphaned)\n  - Demonstrates duplicate node creation on second call for same object\n  - Confirms invariant violation: 2 nodes in linked list, 1 entry in hashmap\n- **Tool signals**:\n  - Valgrind/ASan would detect the memory leak from orphaned nodes\n  - Static analysis (clang-tidy) could flag that `hashmap_put()` return value/status is not checked\n  - Custom runtime instrumentation tracking `node_map` size vs `node_lookup` size would catch the mismatch\n- **Status**: new\n- **Notes**:\n  - This is distinct from BUG-0004 (SCC refcount underflow) - that was about `release_scc()` decrementing refcount; this is about node creation failure handling\n  - This bug can be triggered by legitimate memory pressure (not just programmer error)\n  - The impact is compounded because:\n    1. Orphaned nodes waste memory (never findable but consume space)\n    2. Duplicate nodes waste even more memory\n    3. The mismatch between `node_map` and `node_lookup` can cause incorrect SCC computation results\n  - The fix should:\n    a) Check `hashmap_had_alloc_failure()` after `hashmap_put()`\n    b) On failure, remove node from `node_map` and free it\n    c) Return NULL to signal allocation failure to caller\n    d) Alternatively, change order: add to hashmap FIRST, then to linked list (simpler rollback)\n  - Related architectural issue: The hashmap API doesn't return a status code, making error handling awkward. Consider changing `hashmap_put()` to return `int` (0=success, -1=failure) instead of using a side-channel flag.\n```","session_id":"5ff58bc7-d628-4d3e-b04a-b0c1fd35d242","total_cost_usd":1.1701386,"usage":{"input_tokens":38883,"cache_creation_input_tokens":0,"cache_read_input_tokens":577536,"output_tokens":6912,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"modelUsage":{"glm-4.7":{"inputTokens":40924,"outputTokens":7106,"cacheReadInputTokens":578176,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.4028148,"contextWindow":200000},"glm-4.5-air":{"inputTokens":159759,"outputTokens":8621,"cacheReadInputTokens":529106,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.7673237999999999,"contextWindow":200000}},"permission_denials":[],"uuid":"a1ddeb10-3efa-44fb-8c07-46caa8113d31"}
