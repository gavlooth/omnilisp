;;; Violet Test Runner - Preprocesses and runs Violet tests
;;;
;;; This bootstraps the preprocessing pipeline and runs tests.

;;; ============================================================
;;; Minimal Preprocessor for Variadic Functions
;;; ============================================================

;;; We need a minimal preprocessor that can run in pure OmniLisp.
;;; This handles the key transformation: variadic function syntax.

(define (preprocess-variadic-define form)
  ;; Transform (define (name . args) body) to working OmniLisp
  ;; The issue: OmniLisp parses (name . args) as improper list
  ;; but doesn't bind 'args' to remaining arguments
  ;;
  ;; Solution: We detect this pattern and transform the function
  ;; to accept a single list parameter
  form)  ;; For now, pass through - we'll fix the functions directly

;;; ============================================================
;;; Fixed Variadic Functions for Testing
;;; ============================================================

;;; Since OmniLisp's parser creates improper lists for (a . b) but
;;; the evaluator doesn't handle rest params, we provide working
;;; implementations using OmniLisp's existing capabilities.

(define (my-concat-2 c1 c2)
  (append c1 c2))

(define (my-concat-3 c1 c2 c3)
  (append c1 (append c2 c3)))

(define (range-1 end)
  (range-step 0 end 1))

(define (range-2 start end)
  (range-step start end 1))

(define (range-3 start end step)
  (range-step start end step))

(define (range-step start end step)
  (if (if (> step 0) (>= start end) (<= start end))
      nil
      (cons start (range-step (+ start step) end step))))

;;; ============================================================
;;; Test Framework
;;; ============================================================

;;; Counters using closures - set! works on let-bound variables
;;; Counter operations: 1=inc, 2=get, 3=reset
(define (make-counter)
  (let ((count 0))
    (lambda (op)
      (if (= op 1)
          (do (set! count (+ count 1)) count)
          (if (= op 2)
              count
              (if (= op 3)
                  (do (set! count 0) count)
                  count))))))

(define *tests-run* (make-counter))
(define *tests-passed* (make-counter))
(define *tests-failed* (make-counter))

(define (list-equal? a b)
  (if (and (null? a) (null? b))
      t
      (if (or (null? a) (null? b))
          nil
          (if (and (pair? a) (pair? b))
              (and (list-equal? (car a) (car b))
                   (list-equal? (cdr a) (cdr b)))
              (= a b)))))

(define (pair? x)
  ;; Check if x is a cons cell using ctr-tag
  (= (ctr-tag x) (quote cell)))

(define (assert-equal name expected actual)
  (do
    (*tests-run* 1)  ; inc
    (if (list-equal? expected actual)
        (do
          (*tests-passed* 1)  ; inc
          (display "PASS: ")
          (display name)
          (newline))
        (do
          (*tests-failed* 1)  ; inc
          (display "FAIL: ")
          (display name)
          (newline)
          (display "  expected: ")
          (print expected)
          (display "  actual:   ")
          (print actual)))))

;;; ============================================================
;;; Core Definitions
;;; ============================================================

(define first car)
(define rest cdr)
(define reduce fold)
(define count length)

(define (nil? x) (null? x))
(define (seq coll) (if (null? coll) nil coll))
(define (next coll) (let ((r (rest coll))) (if (null? r) nil r)))
(define (second coll) (first (next coll)))

(define (pos? n) (> n 0))
(define (neg? n) (< n 0))
(define (even? n) (= (% n 2) 0))
(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(define (some? x) (not (null? x)))

(define (take n coll)
  (if (or (<= n 0) (null? coll))
      nil
      (cons (first coll) (take (- n 1) (rest coll)))))

(define (drop n coll)
  (if (or (<= n 0) (null? coll))
      coll
      (drop (- n 1) (rest coll))))

(define (take-while pred coll)
  (if (null? coll)
      nil
      (if (pred (first coll))
          (cons (first coll) (take-while pred (rest coll)))
          nil)))

(define (drop-while pred coll)
  (if (null? coll)
      nil
      (if (pred (first coll))
          (drop-while pred (rest coll))
          coll)))

(define (partition n coll)
  (if (< (count coll) n)
      nil
      (cons (take n coll) (partition n (drop n coll)))))

(define (partition-all n coll)
  (if (null? coll)
      nil
      (cons (take n coll) (partition-all n (drop n coll)))))

(define (interleave c1 c2)
  (if (or (null? c1) (null? c2))
      nil
      (cons (first c1)
            (cons (first c2)
                  (interleave (rest c1) (rest c2))))))

(define (interpose sep coll)
  (if (or (null? coll) (null? (cdr coll)))
      coll
      (cons (first coll)
            (cons sep
                  (interpose sep (rest coll))))))

(define (member x coll)
  (if (null? coll)
      nil
      (if (= x (first coll))
          t
          (member x (rest coll)))))

(define (distinct-step xs seen)
  (if (null? xs)
      nil
      (let ((x (first xs)))
        (if (member x seen)
            (distinct-step (rest xs) seen)
            (cons x (distinct-step (rest xs) (cons x seen)))))))

(define (distinct coll)
  (distinct-step coll nil))

(define (flatten coll)
  (if (null? coll)
      nil
      (if (pair? (first coll))
          (append (flatten (first coll)) (flatten (rest coll)))
          (cons (first coll) (flatten (rest coll))))))

(define (some pred coll)
  (if (null? coll)
      nil
      (if (pred (first coll))
          t
          (some pred (rest coll)))))

(define (every? pred coll)
  (if (null? coll)
      t
      (if (pred (first coll))
          (every? pred (rest coll))
          nil)))

(define (repeat n x)
  (if (<= n 0) nil (cons x (repeat (- n 1) x))))

(define (iterate n f x)
  (if (<= n 0) nil (cons x (iterate (- n 1) f (f x)))))

;;; ============================================================
;;; TESTS
;;; ============================================================

(display "=== Violet Tests ===")
(newline)
(newline)

;;; take tests
(display "-- take --")
(newline)
(assert-equal "take 1" (quote (1)) (take 1 (quote (1 2 3 4 5))))
(assert-equal "take 3" (quote (1 2 3)) (take 3 (quote (1 2 3 4 5))))
(assert-equal "take 5" (quote (1 2 3 4 5)) (take 5 (quote (1 2 3 4 5))))
(assert-equal "take 9 (overflow)" (quote (1 2 3 4 5)) (take 9 (quote (1 2 3 4 5))))
(assert-equal "take 0" nil (take 0 (quote (1 2 3 4 5))))
(assert-equal "take -1" nil (take -1 (quote (1 2 3 4 5))))

;;; drop tests
(display "-- drop --")
(newline)
(assert-equal "drop 1" (quote (2 3 4 5)) (drop 1 (quote (1 2 3 4 5))))
(assert-equal "drop 3" (quote (4 5)) (drop 3 (quote (1 2 3 4 5))))
(assert-equal "drop 5" nil (drop 5 (quote (1 2 3 4 5))))
(assert-equal "drop 9 (overflow)" nil (drop 9 (quote (1 2 3 4 5))))
(assert-equal "drop 0" (quote (1 2 3 4 5)) (drop 0 (quote (1 2 3 4 5))))

;;; take-while tests
(display "-- take-while --")
(newline)
(assert-equal "take-while empty" nil (take-while pos? nil))
(assert-equal "take-while all pass" (quote (1 2 3 4)) (take-while pos? (quote (1 2 3 4))))
(assert-equal "take-while partial" (quote (1 2 3)) (take-while pos? (quote (1 2 3 -1))))
(assert-equal "take-while none pass" nil (take-while pos? (quote (-1 1 2 3))))

;;; drop-while tests
(display "-- drop-while --")
(newline)
(assert-equal "drop-while empty" nil (drop-while pos? nil))
(assert-equal "drop-while all pass" nil (drop-while pos? (quote (1 2 3 4))))
(assert-equal "drop-while partial" (quote (-1)) (drop-while pos? (quote (1 2 3 -1))))
(assert-equal "drop-while mid" (quote (-1 2 3)) (drop-while pos? (quote (1 -1 2 3))))

;;; partition tests
(display "-- partition --")
(newline)
(assert-equal "partition incomplete" (quote ((1 2))) (partition 2 (quote (1 2 3))))
(assert-equal "partition exact" (quote ((1 2) (3 4))) (partition 2 (quote (1 2 3 4))))
(assert-equal "partition empty" nil (partition 2 nil))

;;; partition-all tests
(display "-- partition-all --")
(newline)
(assert-equal "partition-all" (quote ((1 2 3 4) (5 6 7 8) (9))) (partition-all 4 (quote (1 2 3 4 5 6 7 8 9))))

;;; interleave tests
(display "-- interleave --")
(newline)
(assert-equal "interleave equal" (quote (1 3 2 4)) (interleave (quote (1 2)) (quote (3 4))))
(assert-equal "interleave unequal" (quote (1 3)) (interleave (quote (1)) (quote (3 4))))
(assert-equal "interleave empty" nil (interleave nil (quote (3 4))))

;;; interpose tests
(display "-- interpose --")
(newline)
(assert-equal "interpose empty" nil (interpose 0 nil))
(assert-equal "interpose single" (quote (1)) (interpose 0 (quote (1))))
(assert-equal "interpose two" (quote (1 0 2)) (interpose 0 (quote (1 2))))
(assert-equal "interpose three" (quote (1 0 2 0 3)) (interpose 0 (quote (1 2 3))))

;;; distinct tests
(display "-- distinct --")
(newline)
(assert-equal "distinct no dups" (quote (1 2 3)) (distinct (quote (1 2 3))))
(assert-equal "distinct with dups" (quote (1 2 3)) (distinct (quote (1 2 3 1 1 1))))
(assert-equal "distinct many dups" (quote (1 2 3)) (distinct (quote (1 2 3 1 2 2 1 1))))

;;; flatten tests
(display "-- flatten --")
(newline)
(assert-equal "flatten nil" nil (flatten nil))
(assert-equal "flatten nested" (quote (1 2 3 4 5)) (flatten (quote ((1 2) (3 4 (5))))))
(assert-equal "flatten flat" (quote (1 2 3 4 5)) (flatten (quote (1 2 3 4 5))))

;;; concat tests (using fixed-arity versions)
(display "-- concat --")
(newline)
(assert-equal "concat two" (quote (1 2 3 4)) (my-concat-2 (quote (1 2)) (quote (3 4))))
(assert-equal "concat three" (quote (1 2 3 4 5 6)) (my-concat-3 (quote (1 2)) (quote (3 4)) (quote (5 6))))

;;; some tests
(display "-- some --")
(newline)
(assert-equal "some found" t (some pos? (quote (1))))
(assert-equal "some not found" nil (some pos? (quote (-1))))
(assert-equal "some partial" t (some pos? (quote (-1 2))))

;;; every? tests
(display "-- every? --")
(newline)
(assert-equal "every? single true" t (every? pos? (quote (1))))
(assert-equal "every? all true" t (every? pos? (quote (1 2 3 4 5))))
(assert-equal "every? single false" nil (every? pos? (quote (-1))))
(assert-equal "every? partial false" nil (every? pos? (quote (1 -2))))

;;; range tests (using fixed-arity versions)
(display "-- range --")
(newline)
(assert-equal "range 0" nil (range-1 0))
(assert-equal "range 1" (quote (0)) (range-1 1))
(assert-equal "range 5" (quote (0 1 2 3 4)) (range-1 5))
(assert-equal "range 0 3" (quote (0 1 2)) (range-2 0 3))
(assert-equal "range 3 9 2" (quote (3 5 7)) (range-3 3 9 2))
(assert-equal "range neg step" (quote (10 8 6 4 2)) (range-3 10 0 -2))

;;; repeat tests
(display "-- repeat --")
(newline)
(assert-equal "repeat 0" nil (repeat 0 7))
(assert-equal "repeat 5" (quote (7 7 7 7 7)) (repeat 5 7))

;;; iterate tests
(display "-- iterate --")
(newline)
(assert-equal "iterate 1" (quote (0)) (iterate 1 inc 0))
(assert-equal "iterate 5" (quote (0 1 2 3 4)) (iterate 5 inc 0))

;;; ========== Summary ==========
(newline)
(display "=== Summary ===")
(newline)
(display "Passed: ")
(display (*tests-passed* 2))  ; get
(display " / ")
(display (*tests-run* 2))  ; get
(newline)
(if (= (*tests-failed* 2) 0)  ; get
    (display "All tests passed!")
    (do (display "Failed: ") (display (*tests-failed* 2))))
(newline)
