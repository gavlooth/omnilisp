; ===========================================
; SciComp.BLAS - Complete BLAS Bindings
; ===========================================
;
; Exhaustive bindings for BLAS (Basic Linear Algebra Subprograms)
; Covers ALL Level 1, 2, and 3 operations for:
;   - Single precision (S)
;   - Double precision (D)
;   - Complex single (C)
;   - Complex double (Z)
;
; Reference: http://www.netlib.org/blas/

; ===========================================
; Library Loading
; ===========================================

(import {ffi :linux "libopenblas.so"
             :darwin "libopenblas.dylib"
        :as blas})

; ===========================================
; CBLAS Constants
; ===========================================

; Matrix layout
(define CblasRowMajor    101)
(define CblasColMajor    102)

; Transpose options
(define CblasNoTrans     111)
(define CblasTrans       112)
(define CblasConjTrans   113)

; Upper/lower triangular
(define CblasUpper       121)
(define CblasLower       122)

; Diagonal type
(define CblasNonUnit     131)
(define CblasUnit        132)

; Side (left/right multiply)
(define CblasLeft        141)
(define CblasRight       142)

; ===========================================
; Data Types
; ===========================================

; Real vector (double precision)
(deftype Vector
  (data   {CPtr CDouble})
  (size   {CSize})
  (stride {CInt})
  (owner  {CBool}))

; Real vector (single precision)
(deftype VectorF
  (data   {CPtr CFloat})
  (size   {CSize})
  (stride {CInt})
  (owner  {CBool}))

; Complex number (double precision) - stored as [real, imag]
(deftype Complex
  (real {CDouble})
  (imag {CDouble}))

; Complex vector (double precision)
(deftype VectorZ
  (data   {CPtr CDouble})  ; Interleaved [r0,i0,r1,i1,...]
  (size   {CSize})
  (stride {CInt})
  (owner  {CBool}))

; Complex vector (single precision)
(deftype VectorC
  (data   {CPtr CFloat})
  (size   {CSize})
  (stride {CInt})
  (owner  {CBool}))

; Real matrix (double precision, row-major)
(deftype Matrix
  (data   {CPtr CDouble})
  (rows   {CSize})
  (cols   {CSize})
  (ld     {CSize})
  (layout {CInt})
  (owner  {CBool}))

; Real matrix (single precision)
(deftype MatrixF
  (data   {CPtr CFloat})
  (rows   {CSize})
  (cols   {CSize})
  (ld     {CSize})
  (layout {CInt})
  (owner  {CBool}))

; Complex matrix (double precision)
(deftype MatrixZ
  (data   {CPtr CDouble})
  (rows   {CSize})
  (cols   {CSize})
  (ld     {CSize})
  (layout {CInt})
  (owner  {CBool}))

; Complex matrix (single precision)
(deftype MatrixC
  (data   {CPtr CFloat})
  (rows   {CSize})
  (cols   {CSize})
  (ld     {CSize})
  (layout {CInt})
  (owner  {CBool}))

; Packed triangular/symmetric matrix
(deftype PackedMatrix
  (data   {CPtr CDouble})
  (n      {CSize})
  (uplo   {CInt})
  (owner  {CBool}))

; Banded matrix
(deftype BandMatrix
  (data   {CPtr CDouble})
  (rows   {CSize})
  (cols   {CSize})
  (kl     {CSize})          ; Number of subdiagonals
  (ku     {CSize})          ; Number of superdiagonals
  (ld     {CSize})
  (owner  {CBool}))

; =====================================================================
; BLAS LEVEL 1 - VECTOR-VECTOR OPERATIONS
; =====================================================================

; -------------------------------------------
; Double Precision (D)
; -------------------------------------------

; DROTG: Generate Givens rotation
(define {extern blas/cblas_drotg}
  [a {CPtr CDouble}]        ; Modified
  [b {CPtr CDouble}]        ; Modified
  [c {CPtr CDouble}]        ; Output: cosine
  [s {CPtr CDouble}]        ; Output: sine
  -> {Nothing})

; DROTMG: Generate modified Givens rotation
(define {extern blas/cblas_drotmg}
  [d1    {CPtr CDouble}]
  [d2    {CPtr CDouble}]
  [b1    {CPtr CDouble}]
  [b2    {CDouble}]
  [P     {CPtr CDouble}]    ; 5-element param array
  -> {Nothing})

; DROT: Apply Givens rotation
(define {extern blas/cblas_drot}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  [y    {CPtr CDouble}]
  [incy {CInt}]
  [c    {CDouble}]          ; Cosine
  [s    {CDouble}]          ; Sine
  -> {Nothing})

; DROTM: Apply modified Givens rotation
(define {extern blas/cblas_drotm}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  [y    {CPtr CDouble}]
  [incy {CInt}]
  [P    {CPtr CDouble}]
  -> {Nothing})

; DSWAP: Swap vectors
(define {extern blas/cblas_dswap}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  [y    {CPtr CDouble}]
  [incy {CInt}]
  -> {Nothing})

; DSCAL: Scale vector x := alpha*x
(define {extern blas/cblas_dscal}
  [n     {CInt}]
  [alpha {CDouble}]
  [x     {CPtr CDouble}]
  [incx  {CInt}]
  -> {Nothing})

; DCOPY: Copy vector y := x
(define {extern blas/cblas_dcopy}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  [y    {CPtr CDouble}]
  [incy {CInt}]
  -> {Nothing})

; DAXPY: y := alpha*x + y
(define {extern blas/cblas_daxpy}
  [n     {CInt}]
  [alpha {CDouble}]
  [x     {CPtr CDouble}]
  [incx  {CInt}]
  [y     {CPtr CDouble}]
  [incy  {CInt}]
  -> {Nothing})

; DDOT: Dot product
(define {extern blas/cblas_ddot}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  [y    {CPtr CDouble}]
  [incy {CInt}]
  -> {CDouble})

; DSDOT: Dot product with extended precision accumulation
(define {extern blas/cblas_dsdot}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  [y    {CPtr CFloat}]
  [incy {CInt}]
  -> {CDouble})

; DNRM2: Euclidean norm
(define {extern blas/cblas_dnrm2}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  -> {CDouble})

; DASUM: Sum of absolute values
(define {extern blas/cblas_dasum}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  -> {CDouble})

; IDAMAX: Index of max absolute value
(define {extern blas/cblas_idamax}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  -> {CSize})

; IDAMIN: Index of min absolute value (extension)
(define {extern blas/cblas_idamin}
  [n    {CInt}]
  [x    {CPtr CDouble}]
  [incx {CInt}]
  -> {CSize})

; -------------------------------------------
; Single Precision (S)
; -------------------------------------------

(define {extern blas/cblas_srotg}
  [a {CPtr CFloat}]
  [b {CPtr CFloat}]
  [c {CPtr CFloat}]
  [s {CPtr CFloat}]
  -> {Nothing})

(define {extern blas/cblas_srotmg}
  [d1 {CPtr CFloat}]
  [d2 {CPtr CFloat}]
  [b1 {CPtr CFloat}]
  [b2 {CFloat}]
  [P  {CPtr CFloat}]
  -> {Nothing})

(define {extern blas/cblas_srot}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  [y    {CPtr CFloat}]
  [incy {CInt}]
  [c    {CFloat}]
  [s    {CFloat}]
  -> {Nothing})

(define {extern blas/cblas_srotm}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  [y    {CPtr CFloat}]
  [incy {CInt}]
  [P    {CPtr CFloat}]
  -> {Nothing})

(define {extern blas/cblas_sswap}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  [y    {CPtr CFloat}]
  [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_sscal}
  [n     {CInt}]
  [alpha {CFloat}]
  [x     {CPtr CFloat}]
  [incx  {CInt}]
  -> {Nothing})

(define {extern blas/cblas_scopy}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  [y    {CPtr CFloat}]
  [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_saxpy}
  [n     {CInt}]
  [alpha {CFloat}]
  [x     {CPtr CFloat}]
  [incx  {CInt}]
  [y     {CPtr CFloat}]
  [incy  {CInt}]
  -> {Nothing})

(define {extern blas/cblas_sdot}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  [y    {CPtr CFloat}]
  [incy {CInt}]
  -> {CFloat})

(define {extern blas/cblas_sdsdot}
  [n    {CInt}]
  [sb   {CFloat}]           ; Scalar to add
  [x    {CPtr CFloat}]
  [incx {CInt}]
  [y    {CPtr CFloat}]
  [incy {CInt}]
  -> {CFloat})

(define {extern blas/cblas_snrm2}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  -> {CFloat})

(define {extern blas/cblas_sasum}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  -> {CFloat})

(define {extern blas/cblas_isamax}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  -> {CSize})

(define {extern blas/cblas_isamin}
  [n    {CInt}]
  [x    {CPtr CFloat}]
  [incx {CInt}]
  -> {CSize})

; -------------------------------------------
; Complex Double Precision (Z)
; -------------------------------------------

(define {extern blas/cblas_zswap}
  [n    {CInt}]
  [x    {CPtr}]             ; Complex double array
  [incx {CInt}]
  [y    {CPtr}]
  [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zscal}
  [n     {CInt}]
  [alpha {CPtr}]            ; Pointer to complex scalar
  [x     {CPtr}]
  [incx  {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zdscal}
  [n     {CInt}]
  [alpha {CDouble}]         ; Real scalar
  [x     {CPtr}]
  [incx  {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zcopy}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  [y    {CPtr}]
  [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zaxpy}
  [n     {CInt}]
  [alpha {CPtr}]
  [x     {CPtr}]
  [incx  {CInt}]
  [y     {CPtr}]
  [incy  {CInt}]
  -> {Nothing})

; ZDOTU: Unconjugated dot product
(define {extern blas/cblas_zdotu_sub}
  [n      {CInt}]
  [x      {CPtr}]
  [incx   {CInt}]
  [y      {CPtr}]
  [incy   {CInt}]
  [result {CPtr}]           ; Output complex
  -> {Nothing})

; ZDOTC: Conjugated dot product
(define {extern blas/cblas_zdotc_sub}
  [n      {CInt}]
  [x      {CPtr}]
  [incx   {CInt}]
  [y      {CPtr}]
  [incy   {CInt}]
  [result {CPtr}]
  -> {Nothing})

(define {extern blas/cblas_dznrm2}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  -> {CDouble})

(define {extern blas/cblas_dzasum}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  -> {CDouble})

(define {extern blas/cblas_izamax}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  -> {CSize})

; -------------------------------------------
; Complex Single Precision (C)
; -------------------------------------------

(define {extern blas/cblas_cswap}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  [y    {CPtr}]
  [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cscal}
  [n     {CInt}]
  [alpha {CPtr}]
  [x     {CPtr}]
  [incx  {CInt}]
  -> {Nothing})

(define {extern blas/cblas_csscal}
  [n     {CInt}]
  [alpha {CFloat}]
  [x     {CPtr}]
  [incx  {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ccopy}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  [y    {CPtr}]
  [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_caxpy}
  [n     {CInt}]
  [alpha {CPtr}]
  [x     {CPtr}]
  [incx  {CInt}]
  [y     {CPtr}]
  [incy  {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cdotu_sub}
  [n      {CInt}]
  [x      {CPtr}]
  [incx   {CInt}]
  [y      {CPtr}]
  [incy   {CInt}]
  [result {CPtr}]
  -> {Nothing})

(define {extern blas/cblas_cdotc_sub}
  [n      {CInt}]
  [x      {CPtr}]
  [incx   {CInt}]
  [y      {CPtr}]
  [incy   {CInt}]
  [result {CPtr}]
  -> {Nothing})

(define {extern blas/cblas_scnrm2}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  -> {CFloat})

(define {extern blas/cblas_scasum}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  -> {CFloat})

(define {extern blas/cblas_icamax}
  [n    {CInt}]
  [x    {CPtr}]
  [incx {CInt}]
  -> {CSize})

; =====================================================================
; BLAS LEVEL 2 - MATRIX-VECTOR OPERATIONS
; =====================================================================

; -------------------------------------------
; Double Precision General Matrix (DGEMV, DGBMV)
; -------------------------------------------

; DGEMV: y := alpha*A*x + beta*y (general matrix)
(define {extern blas/cblas_dgemv}
  [layout {CInt}]
  [trans  {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [beta   {CDouble}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  -> {Nothing})

; DGBMV: y := alpha*A*x + beta*y (banded matrix)
(define {extern blas/cblas_dgbmv}
  [layout {CInt}]
  [trans  {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [kl     {CInt}]           ; Subdiagonals
  [ku     {CInt}]           ; Superdiagonals
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [beta   {CDouble}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  -> {Nothing})

; -------------------------------------------
; Double Precision Symmetric/Hermitian Matrix
; -------------------------------------------

; DSYMV: y := alpha*A*x + beta*y (symmetric)
(define {extern blas/cblas_dsymv}
  [layout {CInt}]
  [uplo   {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [beta   {CDouble}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  -> {Nothing})

; DSBMV: y := alpha*A*x + beta*y (symmetric banded)
(define {extern blas/cblas_dsbmv}
  [layout {CInt}]
  [uplo   {CInt}]
  [n      {CInt}]
  [k      {CInt}]           ; Bandwidth
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [beta   {CDouble}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  -> {Nothing})

; DSPMV: y := alpha*A*x + beta*y (symmetric packed)
(define {extern blas/cblas_dspmv}
  [layout {CInt}]
  [uplo   {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [Ap     {CPtr CDouble}]   ; Packed storage
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [beta   {CDouble}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  -> {Nothing})

; -------------------------------------------
; Double Precision Triangular Matrix
; -------------------------------------------

; DTRMV: x := A*x or x := A'*x (triangular)
(define {extern blas/cblas_dtrmv}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [diag   {CInt}]
  [n      {CInt}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  -> {Nothing})

; DTBMV: x := A*x (triangular banded)
(define {extern blas/cblas_dtbmv}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [diag   {CInt}]
  [n      {CInt}]
  [k      {CInt}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  -> {Nothing})

; DTPMV: x := A*x (triangular packed)
(define {extern blas/cblas_dtpmv}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [diag   {CInt}]
  [n      {CInt}]
  [Ap     {CPtr CDouble}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  -> {Nothing})

; DTRSV: Solve A*x = b (triangular)
(define {extern blas/cblas_dtrsv}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [diag   {CInt}]
  [n      {CInt}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  -> {Nothing})

; DTBSV: Solve A*x = b (triangular banded)
(define {extern blas/cblas_dtbsv}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [diag   {CInt}]
  [n      {CInt}]
  [k      {CInt}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  -> {Nothing})

; DTPSV: Solve A*x = b (triangular packed)
(define {extern blas/cblas_dtpsv}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [diag   {CInt}]
  [n      {CInt}]
  [Ap     {CPtr CDouble}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  -> {Nothing})

; -------------------------------------------
; Double Precision Rank-1 Updates
; -------------------------------------------

; DGER: A := alpha*x*y' + A
(define {extern blas/cblas_dger}
  [layout {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  -> {Nothing})

; DSYR: A := alpha*x*x' + A (symmetric rank-1)
(define {extern blas/cblas_dsyr}
  [layout {CInt}]
  [uplo   {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  -> {Nothing})

; DSPR: A := alpha*x*x' + A (symmetric packed rank-1)
(define {extern blas/cblas_dspr}
  [layout {CInt}]
  [uplo   {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [Ap     {CPtr CDouble}]
  -> {Nothing})

; DSYR2: A := alpha*x*y' + alpha*y*x' + A (symmetric rank-2)
(define {extern blas/cblas_dsyr2}
  [layout {CInt}]
  [uplo   {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  -> {Nothing})

; DSPR2: A := alpha*x*y' + alpha*y*x' + A (symmetric packed rank-2)
(define {extern blas/cblas_dspr2}
  [layout {CInt}]
  [uplo   {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [x      {CPtr CDouble}]
  [incx   {CInt}]
  [y      {CPtr CDouble}]
  [incy   {CInt}]
  [Ap     {CPtr CDouble}]
  -> {Nothing})

; -------------------------------------------
; Single Precision Level 2
; -------------------------------------------

(define {extern blas/cblas_sgemv}
  [layout {CInt}] [trans {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  [beta {CFloat}] [y {CPtr CFloat}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_sgbmv}
  [layout {CInt}] [trans {CInt}] [m {CInt}] [n {CInt}]
  [kl {CInt}] [ku {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  [beta {CFloat}] [y {CPtr CFloat}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ssymv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  [beta {CFloat}] [y {CPtr CFloat}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ssbmv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}] [k {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  [beta {CFloat}] [y {CPtr CFloat}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_sspmv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [Ap {CPtr CFloat}]
  [x {CPtr CFloat}] [incx {CInt}]
  [beta {CFloat}] [y {CPtr CFloat}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_strmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_stbmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [k {CInt}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_stpmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [Ap {CPtr CFloat}]
  [x {CPtr CFloat}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_strsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_stbsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [k {CInt}] [A {CPtr CFloat}] [lda {CInt}]
  [x {CPtr CFloat}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_stpsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [Ap {CPtr CFloat}]
  [x {CPtr CFloat}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_sger}
  [layout {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CFloat}] [x {CPtr CFloat}] [incx {CInt}]
  [y {CPtr CFloat}] [incy {CInt}]
  [A {CPtr CFloat}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ssyr}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [x {CPtr CFloat}] [incx {CInt}]
  [A {CPtr CFloat}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_sspr}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [x {CPtr CFloat}] [incx {CInt}]
  [Ap {CPtr CFloat}]
  -> {Nothing})

(define {extern blas/cblas_ssyr2}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [x {CPtr CFloat}] [incx {CInt}]
  [y {CPtr CFloat}] [incy {CInt}]
  [A {CPtr CFloat}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_sspr2}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [x {CPtr CFloat}] [incx {CInt}]
  [y {CPtr CFloat}] [incy {CInt}]
  [Ap {CPtr CFloat}]
  -> {Nothing})

; -------------------------------------------
; Complex Double Precision Level 2
; -------------------------------------------

(define {extern blas/cblas_zgemv}
  [layout {CInt}] [trans {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zgbmv}
  [layout {CInt}] [trans {CInt}] [m {CInt}] [n {CInt}]
  [kl {CInt}] [ku {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zhemv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zhbmv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zhpmv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [Ap {CPtr}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztrmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztbmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [k {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztpmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [Ap {CPtr}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztrsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztbsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [k {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztpsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [Ap {CPtr}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zgeru}
  [layout {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zgerc}
  [layout {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zher}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CDouble}] [x {CPtr}] [incx {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zhpr}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CDouble}] [x {CPtr}] [incx {CInt}]
  [Ap {CPtr}]
  -> {Nothing})

(define {extern blas/cblas_zher2}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zhpr2}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [Ap {CPtr}]
  -> {Nothing})

; -------------------------------------------
; Complex Single Precision Level 2
; -------------------------------------------

(define {extern blas/cblas_cgemv}
  [layout {CInt}] [trans {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cgbmv}
  [layout {CInt}] [trans {CInt}] [m {CInt}] [n {CInt}]
  [kl {CInt}] [ku {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_chemv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_chbmv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_chpmv}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [Ap {CPtr}]
  [x {CPtr}] [incx {CInt}]
  [beta {CPtr}] [y {CPtr}] [incy {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctrmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctbmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [k {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctpmv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [Ap {CPtr}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctrsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctbsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [k {CInt}] [A {CPtr}] [lda {CInt}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctpsv}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}] [diag {CInt}]
  [n {CInt}] [Ap {CPtr}]
  [x {CPtr}] [incx {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cgeru}
  [layout {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cgerc}
  [layout {CInt}] [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cher}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [x {CPtr}] [incx {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_chpr}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CFloat}] [x {CPtr}] [incx {CInt}]
  [Ap {CPtr}]
  -> {Nothing})

(define {extern blas/cblas_cher2}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [A {CPtr}] [lda {CInt}]
  -> {Nothing})

(define {extern blas/cblas_chpr2}
  [layout {CInt}] [uplo {CInt}] [n {CInt}]
  [alpha {CPtr}] [x {CPtr}] [incx {CInt}]
  [y {CPtr}] [incy {CInt}]
  [Ap {CPtr}]
  -> {Nothing})

; =====================================================================
; BLAS LEVEL 3 - MATRIX-MATRIX OPERATIONS
; =====================================================================

; -------------------------------------------
; Double Precision
; -------------------------------------------

; DGEMM: C := alpha*op(A)*op(B) + beta*C
(define {extern blas/cblas_dgemm}
  [layout {CInt}]
  [transA {CInt}]
  [transB {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [k      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [B      {CPtr CDouble}]
  [ldb    {CInt}]
  [beta   {CDouble}]
  [C      {CPtr CDouble}]
  [ldc    {CInt}]
  -> {Nothing})

; DSYMM: C := alpha*A*B + beta*C or C := alpha*B*A + beta*C (A symmetric)
(define {extern blas/cblas_dsymm}
  [layout {CInt}]
  [side   {CInt}]
  [uplo   {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [B      {CPtr CDouble}]
  [ldb    {CInt}]
  [beta   {CDouble}]
  [C      {CPtr CDouble}]
  [ldc    {CInt}]
  -> {Nothing})

; DSYRK: C := alpha*A*A' + beta*C or C := alpha*A'*A + beta*C (symmetric rank-k)
(define {extern blas/cblas_dsyrk}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [n      {CInt}]
  [k      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [beta   {CDouble}]
  [C      {CPtr CDouble}]
  [ldc    {CInt}]
  -> {Nothing})

; DSYR2K: C := alpha*A*B' + alpha*B*A' + beta*C (symmetric rank-2k)
(define {extern blas/cblas_dsyr2k}
  [layout {CInt}]
  [uplo   {CInt}]
  [trans  {CInt}]
  [n      {CInt}]
  [k      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [B      {CPtr CDouble}]
  [ldb    {CInt}]
  [beta   {CDouble}]
  [C      {CPtr CDouble}]
  [ldc    {CInt}]
  -> {Nothing})

; DTRMM: B := alpha*op(A)*B or B := alpha*B*op(A) (A triangular)
(define {extern blas/cblas_dtrmm}
  [layout {CInt}]
  [side   {CInt}]
  [uplo   {CInt}]
  [transA {CInt}]
  [diag   {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [B      {CPtr CDouble}]
  [ldb    {CInt}]
  -> {Nothing})

; DTRSM: Solve op(A)*X = alpha*B or X*op(A) = alpha*B
(define {extern blas/cblas_dtrsm}
  [layout {CInt}]
  [side   {CInt}]
  [uplo   {CInt}]
  [transA {CInt}]
  [diag   {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [B      {CPtr CDouble}]
  [ldb    {CInt}]
  -> {Nothing})

; -------------------------------------------
; Single Precision
; -------------------------------------------

(define {extern blas/cblas_sgemm}
  [layout {CInt}] [transA {CInt}] [transB {CInt}]
  [m {CInt}] [n {CInt}] [k {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [B {CPtr CFloat}] [ldb {CInt}]
  [beta {CFloat}] [C {CPtr CFloat}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ssymm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [B {CPtr CFloat}] [ldb {CInt}]
  [beta {CFloat}] [C {CPtr CFloat}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ssyrk}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [beta {CFloat}] [C {CPtr CFloat}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ssyr2k}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [B {CPtr CFloat}] [ldb {CInt}]
  [beta {CFloat}] [C {CPtr CFloat}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_strmm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}] [transA {CInt}] [diag {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [B {CPtr CFloat}] [ldb {CInt}]
  -> {Nothing})

(define {extern blas/cblas_strsm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}] [transA {CInt}] [diag {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CFloat}] [A {CPtr CFloat}] [lda {CInt}]
  [B {CPtr CFloat}] [ldb {CInt}]
  -> {Nothing})

; -------------------------------------------
; Complex Double Precision
; -------------------------------------------

(define {extern blas/cblas_zgemm}
  [layout {CInt}] [transA {CInt}] [transB {CInt}]
  [m {CInt}] [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zsymm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zhemm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zsyrk}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zherk}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CDouble}] [A {CPtr}] [lda {CInt}]
  [beta {CDouble}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zsyr2k}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_zher2k}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CDouble}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztrmm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}] [transA {CInt}] [diag {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ztrsm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}] [transA {CInt}] [diag {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  -> {Nothing})

; -------------------------------------------
; Complex Single Precision
; -------------------------------------------

(define {extern blas/cblas_cgemm}
  [layout {CInt}] [transA {CInt}] [transB {CInt}]
  [m {CInt}] [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_csymm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_chemm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_csyrk}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cherk}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CFloat}] [A {CPtr}] [lda {CInt}]
  [beta {CFloat}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_csyr2k}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CPtr}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_cher2k}
  [layout {CInt}] [uplo {CInt}] [trans {CInt}]
  [n {CInt}] [k {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  [beta {CFloat}] [C {CPtr}] [ldc {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctrmm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}] [transA {CInt}] [diag {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  -> {Nothing})

(define {extern blas/cblas_ctrsm}
  [layout {CInt}] [side {CInt}] [uplo {CInt}] [transA {CInt}] [diag {CInt}]
  [m {CInt}] [n {CInt}]
  [alpha {CPtr}] [A {CPtr}] [lda {CInt}]
  [B {CPtr}] [ldb {CInt}]
  -> {Nothing})

; =====================================================================
; BLAS EXTENSIONS (OpenBLAS/MKL specific)
; =====================================================================

; DOMATCOPY: Out-of-place matrix transpose/copy
(define {extern blas/cblas_domatcopy}
  [layout {CInt}]
  [trans  {CInt}]
  [rows   {CSize}]
  [cols   {CSize}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CSize}]
  [B      {CPtr CDouble}]
  [ldb    {CSize}]
  -> {Nothing})

; DIMATCOPY: In-place matrix transpose
(define {extern blas/cblas_dimatcopy}
  [layout {CInt}]
  [trans  {CInt}]
  [rows   {CSize}]
  [cols   {CSize}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CSize}]
  [ldb    {CSize}]
  -> {Nothing})

; DGEADD: Matrix addition C := alpha*A + beta*B
(define {extern blas/cblas_dgeadd}
  [layout {CInt}]
  [m      {CInt}]
  [n      {CInt}]
  [alpha  {CDouble}]
  [A      {CPtr CDouble}]
  [lda    {CInt}]
  [beta   {CDouble}]
  [B      {CPtr CDouble}]
  [ldb    {CInt}]
  -> {Nothing})

; Thread control
(define {extern blas/openblas_set_num_threads}
  [num_threads {CInt}]
  -> {Nothing})

(define {extern blas/openblas_get_num_threads}
  -> {CInt})

(define {extern blas/openblas_get_num_procs}
  -> {CInt})

(define {extern blas/openblas_get_config}
  -> {CString})

(define {extern blas/openblas_get_corename}
  -> {CString})

; =====================================================================
; HIGH-LEVEL API
; =====================================================================

; Include all the high-level functions from before...
; (vec-new, vec-dot, mat-mul, etc.)

; Vector constructors
(define (vec-new n)
  (let ((data (ffi/alloc-array {CDouble} n)))
    (mk-Vector data n 1 1)))

(define (vec-zeros n)
  (let ((v (vec-new n)))
    (ffi/memset (Vector-data v) 0 (* n 8))
    v))

(define (vec-ones n)
  (let ((v (vec-new n)))
    (letrec ((fill (lambda (i)
                     (if (>= i n) ()
                         (begin
                           (ffi/array-set! (Vector-data v) i 1.0)
                           (fill (+ i 1)))))))
      (fill 0))
    v))

(define (vec-from-list xs)
  (let ((n (length xs)))
    (let ((v (vec-new n)))
      (letrec ((fill (lambda (i xs)
                       (if (null? xs) ()
                           (begin
                             (ffi/array-set! (Vector-data v) i (car xs))
                             (fill (+ i 1) (cdr xs)))))))
        (fill 0 xs))
      v)))

(define (vec-get v i)
  (ffi/array-get (Vector-data v) i))

(define (vec-set! v i val)
  (ffi/array-set! (Vector-data v) i val))

(define (vec-free! v)
  (if (= (Vector-owner v) 1)
      (ffi/free (Vector-data v))
      ()))

(define (vec-to-list v)
  (letrec ((collect (lambda (i acc)
                      (if (< i 0) acc
                          (collect (- i 1) (cons (vec-get v i) acc))))))
    (collect (- (Vector-size v) 1) '())))

; Vector operations using BLAS
(define (vec-dot x y)
  (cblas_ddot (Vector-size x)
              (Vector-data x) (Vector-stride x)
              (Vector-data y) (Vector-stride y)))

(define (vec-norm x)
  (cblas_dnrm2 (Vector-size x) (Vector-data x) (Vector-stride x)))

(define (vec-asum x)
  (cblas_dasum (Vector-size x) (Vector-data x) (Vector-stride x)))

(define (vec-iamax x)
  (cblas_idamax (Vector-size x) (Vector-data x) (Vector-stride x)))

(define (vec-scale! alpha x)
  (cblas_dscal (Vector-size x) alpha (Vector-data x) (Vector-stride x)))

(define (vec-axpy! alpha x y)
  (cblas_daxpy (Vector-size x) alpha
               (Vector-data x) (Vector-stride x)
               (Vector-data y) (Vector-stride y)))

(define (vec-copy x)
  (let ((result (vec-new (Vector-size x))))
    (cblas_dcopy (Vector-size x)
                 (Vector-data x) (Vector-stride x)
                 (Vector-data result) 1)
    result))

(define (vec-swap! x y)
  (cblas_dswap (Vector-size x)
               (Vector-data x) (Vector-stride x)
               (Vector-data y) (Vector-stride y)))

; Functional vector operations
(define (vec-add x y)
  (let ((z (vec-copy x)))
    (vec-axpy! 1.0 y z)
    z))

(define (vec-sub x y)
  (let ((z (vec-copy x)))
    (vec-axpy! -1.0 y z)
    z))

(define (vec-scale alpha x)
  (let ((z (vec-copy x)))
    (vec-scale! alpha z)
    z))

; Givens rotation
(define (givens-rotation a b)
  (let ((a-ptr (ffi/alloc {CDouble}))
        (b-ptr (ffi/alloc {CDouble}))
        (c-ptr (ffi/alloc {CDouble}))
        (s-ptr (ffi/alloc {CDouble})))
    (ffi/poke! a-ptr a)
    (ffi/poke! b-ptr b)
    (cblas_drotg a-ptr b-ptr c-ptr s-ptr)
    (let ((c (ffi/peek c-ptr))
          (s (ffi/peek s-ptr)))
      (ffi/free a-ptr)
      (ffi/free b-ptr)
      (ffi/free c-ptr)
      (ffi/free s-ptr)
      (list c s))))

(define (vec-apply-rotation! x y c s)
  (cblas_drot (Vector-size x)
              (Vector-data x) (Vector-stride x)
              (Vector-data y) (Vector-stride y)
              c s))

; Matrix constructors
(define (mat-new rows cols)
  (let ((data (ffi/alloc-array {CDouble} (* rows cols))))
    (mk-Matrix data rows cols cols CblasRowMajor 1)))

(define (mat-zeros rows cols)
  (let ((m (mat-new rows cols)))
    (ffi/memset (Matrix-data m) 0 (* rows cols 8))
    m))

(define (mat-eye n)
  (let ((m (mat-zeros n n)))
    (letrec ((fill (lambda (i)
                     (if (>= i n) ()
                         (begin
                           (mat-set! m i i 1.0)
                           (fill (+ i 1)))))))
      (fill 0))
    m))

(define (mat-from-lists rows-list)
  (let ((nrows (length rows-list))
        (ncols (length (car rows-list))))
    (let ((m (mat-new nrows ncols)))
      (letrec ((fill-rows (lambda (i rows)
                            (if (null? rows) ()
                                (begin
                                  (letrec ((fill-cols (lambda (j cols)
                                                        (if (null? cols) ()
                                                            (begin
                                                              (mat-set! m i j (car cols))
                                                              (fill-cols (+ j 1) (cdr cols)))))))
                                    (fill-cols 0 (car rows)))
                                  (fill-rows (+ i 1) (cdr rows)))))))
        (fill-rows 0 rows-list))
      m)))

(define (mat-get m i j)
  (ffi/array-get (Matrix-data m) (+ (* i (Matrix-ld m)) j)))

(define (mat-set! m i j val)
  (ffi/array-set! (Matrix-data m) (+ (* i (Matrix-ld m)) j) val))

(define (mat-free! m)
  (if (= (Matrix-owner m) 1)
      (ffi/free (Matrix-data m))
      ()))

(define (mat-copy A)
  (let ((B (mat-new (Matrix-rows A) (Matrix-cols A))))
    (ffi/memcpy (Matrix-data B) (Matrix-data A)
                (* (Matrix-rows A) (Matrix-cols A) 8))
    B))

; Matrix-vector multiply
(define (mat-vec-mul! alpha A x beta y)
  (cblas_dgemv (Matrix-layout A) CblasNoTrans
               (Matrix-rows A) (Matrix-cols A)
               alpha (Matrix-data A) (Matrix-ld A)
               (Vector-data x) (Vector-stride x)
               beta (Vector-data y) (Vector-stride y)))

(define (mat-vec-mul A x)
  (let ((y (vec-zeros (Matrix-rows A))))
    (mat-vec-mul! 1.0 A x 0.0 y)
    y))

; Matrix-matrix multiply
(define (mat-mul! alpha A B beta C)
  (cblas_dgemm (Matrix-layout A) CblasNoTrans CblasNoTrans
               (Matrix-rows A) (Matrix-cols B) (Matrix-cols A)
               alpha (Matrix-data A) (Matrix-ld A)
               (Matrix-data B) (Matrix-ld B)
               beta (Matrix-data C) (Matrix-ld C)))

(define (mat-mul A B)
  (let ((C (mat-zeros (Matrix-rows A) (Matrix-cols B))))
    (mat-mul! 1.0 A B 0.0 C)
    C))

; Symmetric matrix-vector multiply
(define (mat-symv! alpha A x beta y uplo)
  (cblas_dsymv (Matrix-layout A) uplo
               (Matrix-rows A)
               alpha (Matrix-data A) (Matrix-ld A)
               (Vector-data x) (Vector-stride x)
               beta (Vector-data y) (Vector-stride y)))

; Symmetric rank-1 update
(define (mat-syr! alpha x A uplo)
  (cblas_dsyr (Matrix-layout A) uplo
              (Matrix-rows A)
              alpha (Vector-data x) (Vector-stride x)
              (Matrix-data A) (Matrix-ld A)))

; Symmetric rank-k update
(define (mat-syrk! alpha A beta C uplo trans)
  (cblas_dsyrk (Matrix-layout A) uplo trans
               (Matrix-rows C) (Matrix-cols A)
               alpha (Matrix-data A) (Matrix-ld A)
               beta (Matrix-data C) (Matrix-ld C)))

; Triangular solve
(define (mat-trsv! A x uplo trans diag)
  (cblas_dtrsv (Matrix-layout A) uplo trans diag
               (Matrix-rows A)
               (Matrix-data A) (Matrix-ld A)
               (Vector-data x) (Vector-stride x)))

; Triangular matrix-matrix solve
(define (mat-trsm! alpha A B side uplo trans diag)
  (cblas_dtrsm (Matrix-layout A) side uplo trans diag
               (Matrix-rows B) (Matrix-cols B)
               alpha (Matrix-data A) (Matrix-ld A)
               (Matrix-data B) (Matrix-ld B)))

; Transpose
(define (mat-transpose A)
  (let ((B (mat-new (Matrix-cols A) (Matrix-rows A))))
    (letrec ((transpose-loop
              (lambda (i)
                (if (>= i (Matrix-rows A)) ()
                    (begin
                      (letrec ((inner (lambda (j)
                                        (if (>= j (Matrix-cols A)) ()
                                            (begin
                                              (mat-set! B j i (mat-get A i j))
                                              (inner (+ j 1)))))))
                        (inner 0))
                      (transpose-loop (+ i 1)))))))
      (transpose-loop 0))
    B))

; Scoped resource management
(define-syntax with-vec
  (syntax-rules ()
    ((_ (name expr) body ...)
     (let ((name expr))
       (let ((result (begin body ...)))
         (vec-free! name)
         result)))))

(define-syntax with-mat
  (syntax-rules ()
    ((_ (name expr) body ...)
     (let ((name expr))
       (let ((result (begin body ...)))
         (mat-free! name)
         result)))))

; Thread control wrappers
(define (blas-set-threads! n)
  (openblas_set_num_threads n))

(define (blas-num-threads)
  (openblas_get_num_threads))

(define (blas-num-procs)
  (openblas_get_num_procs))

(define (blas-config)
  (openblas_get_config))

(define (blas-core-name)
  (openblas_get_corename))
