;; ============================================================ 
;; OmniLisp Syntax Test Suite 
;; ============================================================ 

(println "--- Testing 2. Bindings & Functions ---") 

;; 2.1 Function Definitions 
(define (add-v1 x y) (+ x y)) 
(println "V1 (Scheme): " (add-v1 10 20)) 

(define (add-v2 [x y]) (+ x y)) 
(println "V2 (Slot Header): " (add-v2 10 20)) 

(define (add-v3 x {Int} y {Int}) {Int} (+ x y)) 
(println "V3 (Typed Header): " (add-v3 10 20)) 

(define (add-v4 [x {Int} y {Int}]) {Int} (+ x y)) 
(println "V4 (Typed Slot): " (add-v4 10 20)) 

(define add-v5 [x y] (+ x y)) 
(println "V5 (Flat Clojure): " (add-v5 10 20)) 

;; Lambdas 
(println "Lambda: " ((lambda [x] (* x x)) 5)) 
(println "fn shorthand: " ((fn [x] (* x x)) 5)) 
(println "-> shorthand: " ((-> [x y] (+ x y)) 1 2)) 

;; 2.2 Local Bindings 
(println "let: " (let [x 10 y 20] (+ x y))) 

;; 2.3 Destructuring 
(define [da db dc] [1 2 3]) 
(println "define destructure: " da " " db " " dc) 

(println "let destructure: " (let [[lx ly] [100 200]] (+ lx ly))) 

(println "\n--- Testing 3. Sequences ---") 
(println "List: " '(1 2 3)) 
(println "Array literal: " [1 2 3]) 

(println "\n--- Testing 4. Access & Mutation ---") 
(define person #{:name "Alice" :age 30}) 
(println "Map access (.): " person.name) 
(set! da 99) 
(println "set!: " da) 

;; 4.2 Update Functional
(define person2 (update person.age (lambda [x] (+ x 1))))
(println "update functional: " person2.age)
(println "\n--- Testing 5. Type System ---")
;; Verification of annotation parsing (evaluator skips them)
(define x-typed {Int} 42)
(println "Typed var {Int}: " x-typed)

;; 5.4 First-Class Kinds
(define my-type Int)
(println "First-class Kind reference: " my-type)
(println "type? with Kind object: " (type? 100 my-type))

(define (get-string-type) String)
(println "Kind returned from function: " (get-string-type))
(println "type? with returned Kind: " (type? "hello" (get-string-type)))
(println "\n--- Testing 6. Pattern Matching ---")
(println "match simple: "
  (match 1
    1 "one"
    2 "two"
    _ "other"))

(println "match pattern: "
  (match [1 2]
    [x y] (+ x y)
    _ 0))

;; 6.1 Nested destructuring
(println "match nested: "
  (match (list 1 (list 2 3))
    [1 [x y]] (+ x y)
    _ 0))

;; 6.2 Splicing patterns
(println "match splicing: "
  (match [1 2 3 4]
    [x y .. rest] (append (list x y) rest)
    _ nil))

;; 6.3 Boolean match (demonstrates if desugaring)
(println "match boolean: "
  (match true
    true "yes"
    false "no"
    _ "other"))

;; 6.4 Type constraints in patterns (when supported)
;; (println "match with type constraint: "
;;   (match 42
;;     [n {Int}] "is integer"
;;     _ "not integer"))

;; 6.5 Guards (& syntax)
;; (println "match with guard: "
;;   (match 15
;;     [n {Int} & (> n 10)] "large"
;;     [n {Int}] "small"
;;     _ "not integer")) 

(println "\n--- Testing 7. Pika Grammar DSL ---") 
(define [grammar simple] 
  [greeting "hello"]) 
(println "Grammar defined: " simple) 

(println "\n--- Testing 8. Metadata ---") 
(define ^:hot version 1.0) 
(println "Metadata var: " version) 

(println "\nSUCCESS: Syntax suite complete.") 
