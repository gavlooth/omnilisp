/* Generated by OmniLisp Compiler */
/* ASAP Memory Management - Compile-Time Free Injection */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <pthread.h>

typedef enum {
    T_INT, T_SYM, T_CELL, T_NIL, T_NOTHING, T_PRIM, T_LAMBDA, T_CODE, T_ERROR, T_FLOAT
} Tag;

struct Obj;
typedef struct Obj* (*PrimFn)(struct Obj*, struct Obj*);

typedef struct Obj {
    Tag tag;
    int rc;  /* Reference count */
    union {
        int64_t i;
        double f;
        char* s;
        struct { struct Obj* car; struct Obj* cdr; } cell;
        PrimFn prim;
        struct { struct Obj* params; struct Obj* body; struct Obj* env; } lam;
    };
} Obj;

static Obj _nil = { .tag = T_NIL, .rc = 1 };
#define NIL (&_nil)
static Obj _nothing = { .tag = T_NOTHING, .rc = 1 };
#define NOTHING (&_nothing)

static Obj* mk_int(int64_t i) {
    Obj* o = malloc(sizeof(Obj));
    o->tag = T_INT; o->rc = 1; o->i = i;
    return o;
}

static Obj* mk_float(double f) {
    Obj* o = malloc(sizeof(Obj));
    o->tag = T_FLOAT; o->rc = 1; o->f = f;
    return o;
}

static Obj* mk_sym(const char* s) {
    Obj* o = malloc(sizeof(Obj));
    o->tag = T_SYM; o->rc = 1; o->s = strdup(s);
    return o;
}

static Obj* mk_bool(int v) {
    return mk_sym(v ? "true" : "false");
}

static Obj* mk_cell(Obj* car, Obj* cdr) {
    Obj* o = malloc(sizeof(Obj));
    o->tag = T_CELL; o->rc = 1;
    o->cell.car = car; o->cell.cdr = cdr;
    return o;
}

/* Stack-allocated objects - no free needed, auto-cleanup at scope exit */
#define STACK_INT(name, val) \
    Obj _stack_##name = { .tag = T_INT, .rc = 1, .i = (val) }; \
    Obj* name = &_stack_##name

#define STACK_CELL(name, car_val, cdr_val) \
    Obj _stack_##name = { .tag = T_CELL, .rc = 1, .cell = { (car_val), (cdr_val) } }; \
    Obj* name = &_stack_##name

#define IS_STACK_OBJ(o) ((o) && (o)->rc == -1)
#define MARK_STACK(o) ((o)->rc = -1)

static void init_int(Obj* o, int64_t i) {
    o->tag = T_INT; o->rc = -1; o->i = i;
}

static void init_cell(Obj* o, Obj* car, Obj* cdr) {
    o->tag = T_CELL; o->rc = -1;
    o->cell.car = car; o->cell.cdr = cdr;
}

#define car(o) ((o)->cell.car)
#define cdr(o) ((o)->cell.cdr)
#define is_nil(o) ((o) == NIL || ((o) && (o)->tag == T_NIL))

static void inc_ref(Obj* o) { if (o && o != NIL && o != NOTHING) o->rc++; }
static void dec_ref(Obj* o);
static void free_tree(Obj* o);

static void free_unique(Obj* o) {
    if (!o || o == NIL || o == NOTHING) return;
    switch (o->tag) {
    case T_SYM: free(o->s); break;
    case T_CELL: free_unique(o->cell.car); free_unique(o->cell.cdr); break;
    case T_LAMBDA: free_unique(o->lam.params); free_unique(o->lam.body); free_unique(o->lam.env); break;
    default: break;
    }
    free(o);
}

static void free_tree(Obj* o) {
    if (!o || o == NIL || o == NOTHING) return;
    if (o->rc > 1) { o->rc--; return; } /* Shared child - dec only */
    switch (o->tag) {
    case T_SYM: free(o->s); break;
    case T_CELL: free_tree(o->cell.car); free_tree(o->cell.cdr); break;
    case T_LAMBDA: free_tree(o->lam.params); free_tree(o->lam.body); free_tree(o->lam.env); break;
    default: break;
    }
    free(o);
}

static void free_obj(Obj* o) {
    if (!o || o == NIL || o == NOTHING) return;
    if (--o->rc > 0) return;
    switch (o->tag) {
    case T_SYM: free(o->s); break;
    case T_CELL: free_obj(o->cell.car); free_obj(o->cell.cdr); break;
    case T_LAMBDA: free_obj(o->lam.params); free_obj(o->lam.body); free_obj(o->lam.env); break;
    default: break;
    }
    free(o);
}
static void dec_ref(Obj* o) { free_obj(o); }

/* Weak reference: does NOT prevent deallocation.
 * Used for back-edges (parent, prev, etc.) to break cycles.
 * Weak refs are NOT followed during free (no recursive free).
 * Weak refs are auto-nullified when target is freed.
 */
typedef struct WeakRef {
    Obj** slot;           /* Pointer to the weak field in the owner */
    struct WeakRef* next; /* Next weak ref pointing to same target */
} WeakRef;

/* Weak ref list head stored in target object (or separate table) */
static WeakRef* _weak_refs = NULL; /* Global list for simplicity */

static void weak_ref_register(Obj** slot, Obj* target) {
    (void)target; /* For table-based lookup, would use target */
    WeakRef* wr = malloc(sizeof(WeakRef));
    wr->slot = slot;
    wr->next = _weak_refs;
    _weak_refs = wr;
}

static void weak_refs_nullify(Obj* target) {
    /* Called when target is about to be freed - nullify all weak refs */
    WeakRef** prev = &_weak_refs;
    WeakRef* wr = _weak_refs;
    while (wr) {
        if (*(wr->slot) == target) {
            *(wr->slot) = NULL; /* Nullify the weak reference */
            *prev = wr->next;
            WeakRef* to_free = wr;
            wr = wr->next;
            free(to_free);
        } else {
            prev = &wr->next;
            wr = wr->next;
        }
    }
}

/* Set a back-edge field (weak reference) */
#define SET_WEAK(owner, field, target) do { \
    (owner)->field = (target); \
    if (target) weak_ref_register(&(owner)->field, target); \
} while(0)

/* Get a back-edge field (may be NULL if target was freed) */
#define GET_WEAK(owner, field) ((owner)->field)

/* Perceus Reuse: In-place mutation for functional-style updates.
 * When we know an object will be freed immediately before a new allocation
 * of the same size, we can reuse its memory instead of free+malloc.
 */

/* Reuse an object's memory for an integer */
static Obj* reuse_as_int(Obj* old, int64_t val) {
    if (!old || old == NIL || old == NOTHING) return mk_int(val);
    /* Clear old content if needed */
    if (old->tag == T_SYM && old->s) free(old->s);
    else if (old->tag == T_CELL) {
        free_obj(old->cell.car);
        free_obj(old->cell.cdr);
    }
    old->tag = T_INT;
    old->i = val;
    old->rc = 1;
    return old;
}

/* Reuse an object's memory for a cell/cons */
static Obj* reuse_as_cell(Obj* old, Obj* car, Obj* cdr) {
    if (!old || old == NIL || old == NOTHING) return mk_cell(car, cdr);
    /* Clear old content if needed */
    if (old->tag == T_SYM && old->s) free(old->s);
    else if (old->tag == T_CELL) {
        free_obj(old->cell.car);
        free_obj(old->cell.cdr);
    }
    old->tag = T_CELL;
    old->cell.car = car; inc_ref(car);
    old->cell.cdr = cdr; inc_ref(cdr);
    old->rc = 1;
    return old;
}

/* Reuse an object's memory for a float */
static Obj* reuse_as_float(Obj* old, double val) {
    if (!old || old == NIL || old == NOTHING) return mk_float(val);
    /* Clear old content if needed */
    if (old->tag == T_SYM && old->s) free(old->s);
    else if (old->tag == T_CELL) {
        free_obj(old->cell.car);
        free_obj(old->cell.cdr);
    }
    old->tag = T_FLOAT;
    old->f = val;
    old->rc = 1;
    return old;
}

/* Check if object can be reused (unique, about to be freed) */
#define CAN_REUSE(o) ((o) && (o) != NIL && (o) != NOTHING && (o)->rc == 1)

/* Conditional reuse macro - falls back to fresh alloc if can't reuse */
#define REUSE_OR_NEW_INT(old, val) \
    (CAN_REUSE(old) ? reuse_as_int(old, val) : mk_int(val))

#define REUSE_OR_NEW_CELL(old, car, cdr) \
    (CAN_REUSE(old) ? reuse_as_cell(old, car, cdr) : mk_cell(car, cdr))

#define REUSE_OR_NEW_FLOAT(old, val) \
    (CAN_REUSE(old) ? reuse_as_float(old, val) : mk_float(val))

/* RC Elision: Conditional inc/dec based on analysis.
 * When analysis proves RC operations are unnecessary, we skip them:
 * - Unique references: no other refs exist
 * - Stack-allocated: lifetime is scope-bound
 * - Arena/pool: bulk free, no individual tracking
 * - Same region: all refs die together
 */

/* Conditional inc_ref - may be elided */
#define INC_REF_IF_NEEDED(o, can_elide) \
    do { if (!(can_elide)) inc_ref(o); } while(0)

/* Conditional dec_ref - may be elided */
#define DEC_REF_IF_NEEDED(o, can_elide) \
    do { if (!(can_elide)) dec_ref(o); } while(0)

/* No-op for elided RC operations (for clarity in generated code) */
#define RC_ELIDED() ((void)0)

/* Region-local reference: no RC needed within same region */
#define REGION_LOCAL_REF(o) (o)  /* No inc_ref needed */

/* Per-Region External Refcount: Track references into a region.
 * Instead of per-object RC, track external refs to the region.
 * When external_refcount == 0 and scope ends, bulk free entire region.
 */

typedef struct Region {
    int id;
    int external_refcount;  /* Refs from outside this region */
    void* arena;            /* Arena allocator for this region */
    struct Region* parent;  /* Enclosing region */
} Region;

static Region* _current_region = NULL;

static Region* region_new(int id) {
    Region* r = malloc(sizeof(Region));
    r->id = id;
    r->external_refcount = 0;
    r->arena = NULL;  /* Could use arena allocator */
    r->parent = _current_region;
    _current_region = r;
    return r;
}

static void region_end(Region* r) {
    if (!r) return;
    _current_region = r->parent;
    /* If no external refs, could bulk-free arena here */
    if (r->external_refcount == 0) {
        /* Safe to bulk free all objects in region */
    }
    free(r);
}

#define REGION_INC_EXTERNAL(r) do { if (r) (r)->external_refcount++; } while(0)
#define REGION_DEC_EXTERNAL(r) do { if (r) (r)->external_refcount--; } while(0)
#define REGION_CAN_BULK_FREE(r) ((r) && (r)->external_refcount == 0)

/* Borrow/Tether: Keep borrowed objects alive.
 * When iterating over a collection, the collection must stay alive.
 * Tethering increments RC at loop entry, decrements at loop exit.
 */

/* Tether an object to keep it alive during a borrow */
#define TETHER(o) do { if (o) inc_ref(o); } while(0)

/* Release a tether when borrow ends */
#define UNTETHER(o) do { if (o) dec_ref(o); } while(0)

/* Borrow a collection for loop iteration */
#define BORROW_FOR_LOOP(coll) TETHER(coll)

/* End loop borrow */
#define END_LOOP_BORROW(coll) UNTETHER(coll)

/* Scoped tether - automatically releases at scope end */
#define SCOPED_TETHER_DECL(name, o) \
    Obj* name##_tethered = (o); \
    TETHER(name##_tethered)

#define SCOPED_TETHER_END(name) \
    UNTETHER(name##_tethered)

/* Interprocedural Summaries: Ownership annotations for function boundaries.
 * These annotations guide the compiler/reader about ownership transfer.
 * PARAM_BORROWED: Caller keeps ownership, callee borrows.
 * PARAM_CONSUMED: Callee takes ownership, will free.
 * PARAM_PASSTHROUGH: Param passes through to return value.
 * PARAM_CAPTURED: Param is captured in closure/data structure.
 */

/* Parameter ownership annotations (for documentation) */
#define PARAM_BORROWED(p) (p)      /* Borrowed: caller keeps ownership */
#define PARAM_CONSUMED(p) (p)      /* Consumed: callee takes ownership */
#define PARAM_PASSTHROUGH(p) (p)   /* Passthrough: returned to caller */
#define PARAM_CAPTURED(p) (p)      /* Captured: stored in closure/struct */

/* Return ownership annotations */
#define RETURN_FRESH(v) (v)        /* Fresh allocation, caller must free */
#define RETURN_PASSTHROUGH(v) (v)  /* Returns a parameter, no new alloc */
#define RETURN_BORROWED(v) (v)     /* Borrowed ref, don't free */
#define RETURN_NONE() NOTHING      /* Returns nothing */

/* Caller-side ownership handling */
#define CALL_CONSUMED(arg, call_expr) \
    ({ Obj* _result = (call_expr); /* arg ownership transferred */ _result; })

#define CALL_BORROWED(arg, call_expr) \
    ({ Obj* _result = (call_expr); /* caller still owns arg */ _result; })

/* Function summary declaration macro */
#define FUNC_SUMMARY(name, ret_own, allocs, side_effects) \
    /* Summary: name returns ret_own, allocates: allocs, side_effects: side_effects */

/* Ownership transfer assertion (debug builds) */
#ifndef NDEBUG
#define ASSERT_OWNED(o) do { \
    if ((o) && (o) != NIL && (o) != NOTHING && (o)->rc < 1) { \
        fprintf(stderr, "Ownership error: %p has rc=%d\n", (void*)(o), (o)->rc); \
    } \
} while(0)
#else
#define ASSERT_OWNED(o) ((void)0)
#endif

/* Concurrency Ownership: Thread-safe reference counting.
 * THREAD_LOCAL: Data stays in one thread, no sync needed.
 * THREAD_SHARED: Data accessed by multiple threads, needs atomic RC.
 * THREAD_TRANSFER: Data transferred via channel, ownership moves.
 */

/* Atomic reference counting for shared data */
#ifdef __STDC_NO_ATOMICS__
/* Fallback for systems without C11 atomics - use mutex */
static pthread_mutex_t _rc_mutex = PTHREAD_MUTEX_INITIALIZER;
#define ATOMIC_INC_REF(o) do { \
    pthread_mutex_lock(&_rc_mutex); \
    if ((o) && (o) != NIL && (o) != NOTHING) (o)->rc++; \
    pthread_mutex_unlock(&_rc_mutex); \
} while(0)

#define ATOMIC_DEC_REF(o) do { \
    pthread_mutex_lock(&_rc_mutex); \
    if ((o) && (o) != NIL && (o) != NOTHING) { \
        if (--(o)->rc <= 0) { \
            pthread_mutex_unlock(&_rc_mutex); \
            free_obj(o); \
        } else { \
            pthread_mutex_unlock(&_rc_mutex); \
        } \
    } else { pthread_mutex_unlock(&_rc_mutex); } \
} while(0)
#else
/* Using __atomic builtins for GCC/Clang compatibility */
#define ATOMIC_INC_REF(o) do { \
    if ((o) && (o) != NIL && (o) != NOTHING) __atomic_add_fetch(&(o)->rc, 1, __ATOMIC_SEQ_CST); \
} while(0)

#define ATOMIC_DEC_REF(o) do { \
    if ((o) && (o) != NIL && (o) != NOTHING) { \
        if (__atomic_sub_fetch(&(o)->rc, 1, __ATOMIC_SEQ_CST) <= 0) { \
            free_obj(o); \
        } \
    } \
} while(0)
#endif

/* Thread locality annotations */
#define THREAD_LOCAL_VAR(v) (v)      /* No sync needed */
#define THREAD_SHARED_VAR(v) (v)     /* Uses atomic RC */
#define THREAD_TRANSFER_VAR(v) (v)   /* Ownership moves */

/* Channel operations - ownership transfer semantics */
typedef struct Channel {
    Obj** buffer;
    size_t capacity;
    size_t head, tail, count;
    pthread_mutex_t mutex;
    pthread_cond_t not_empty;
    pthread_cond_t not_full;
    int closed;
} Channel;

static Channel* channel_new(size_t capacity) {
    Channel* c = malloc(sizeof(Channel));
    c->buffer = malloc(capacity * sizeof(Obj*));
    c->capacity = capacity;
    c->head = c->tail = c->count = 0;
    pthread_mutex_init(&c->mutex, NULL);
    pthread_cond_init(&c->not_empty, NULL);
    pthread_cond_init(&c->not_full, NULL);
    c->closed = 0;
    return c;
}

/* Send transfers ownership - sender must NOT free after */
static void channel_send(Channel* c, Obj* value) {
    pthread_mutex_lock(&c->mutex);
    while (c->count == c->capacity && !c->closed) {
        pthread_cond_wait(&c->not_full, &c->mutex);
    }
    if (!c->closed) {
        c->buffer[c->tail] = value;  /* Ownership transfers */
        c->tail = (c->tail + 1) % c->capacity;
        c->count++;
        pthread_cond_signal(&c->not_empty);
    }
    pthread_mutex_unlock(&c->mutex);
}

/* Recv receives ownership - receiver must free when done */
static Obj* channel_recv(Channel* c) {
    pthread_mutex_lock(&c->mutex);
    while (c->count == 0 && !c->closed) {
        pthread_cond_wait(&c->not_empty, &c->mutex);
    }
    Obj* value = NIL;
    if (c->count > 0) {
        value = c->buffer[c->head];  /* Ownership transfers */
        c->head = (c->head + 1) % c->capacity;
        c->count--;
        pthread_cond_signal(&c->not_full);
    }
    pthread_mutex_unlock(&c->mutex);
    return value;
}

static void channel_close(Channel* c) {
    pthread_mutex_lock(&c->mutex);
    c->closed = 1;
    pthread_cond_broadcast(&c->not_empty);
    pthread_cond_broadcast(&c->not_full);
    pthread_mutex_unlock(&c->mutex);
}

static void channel_free(Channel* c) {
    if (!c) return;
    /* Free any remaining items in buffer */
    while (c->count > 0) {
        free_obj(c->buffer[c->head]);
        c->head = (c->head + 1) % c->capacity;
        c->count--;
    }
    free(c->buffer);
    pthread_mutex_destroy(&c->mutex);
    pthread_cond_destroy(&c->not_empty);
    pthread_cond_destroy(&c->not_full);
    free(c);
}

/* Ownership transfer macros */
#define SEND_OWNERSHIP(ch, val) do { channel_send(ch, val); /* val no longer owned */ } while(0)
#define RECV_OWNERSHIP(ch, var) do { var = channel_recv(ch); /* var now owned */ } while(0)

/* Thread spawn with captured variable handling */
#define SPAWN_THREAD(fn, arg) do { \
    pthread_t _thread; \
    pthread_create(&_thread, NULL, fn, arg); \
    pthread_detach(_thread); \
} while(0)

/* Mark variable as shared (needs atomic RC) */
#define MARK_SHARED(v) ((void)0)  /* Analysis marker, no runtime cost */

/* Conditional RC based on thread locality analysis */
#define INC_REF_FOR_THREAD(o, needs_atomic) \
    do { if (needs_atomic) ATOMIC_INC_REF(o); else inc_ref(o); } while(0)

#define DEC_REF_FOR_THREAD(o, needs_atomic) \
    do { if (needs_atomic) ATOMIC_DEC_REF(o); else dec_ref(o); } while(0)

static void print_obj(Obj* o) {
    if (!o || o == NOTHING) { printf("nothing"); return; }
    if (is_nil(o)) { printf("()"); return; }
    switch (o->tag) {
    case T_INT: printf("%ld", (long)o->i); break;
    case T_SYM: printf("%s", o->s); break;
    case T_NOTHING: printf("nothing"); break;
    case T_CELL:
        printf("(");
        while (!is_nil(o)) {
            print_obj(car(o));
            o = cdr(o);
            if (!is_nil(o)) printf(" ");
        }
        printf(")");
        break;
    default: printf("#<unknown>"); break;
    }
}
#define omni_print(o) print_obj(o)

static Obj* prim_add(Obj* a, Obj* b) { return mk_int(a->i + b->i); }
static Obj* prim_sub(Obj* a, Obj* b) { return mk_int(a->i - b->i); }
static Obj* prim_mul(Obj* a, Obj* b) { return mk_int(a->i * b->i); }
static Obj* prim_div(Obj* a, Obj* b) { return mk_int(a->i / b->i); }
static Obj* prim_mod(Obj* a, Obj* b) { return mk_int(a->i % b->i); }
static Obj* prim_lt(Obj* a, Obj* b) { return mk_bool(a->i < b->i ? 1 : 0); }
static Obj* prim_gt(Obj* a, Obj* b) { return mk_bool(a->i > b->i ? 1 : 0); }
static Obj* prim_le(Obj* a, Obj* b) { return mk_bool(a->i <= b->i ? 1 : 0); }
static Obj* prim_ge(Obj* a, Obj* b) { return mk_bool(a->i >= b->i ? 1 : 0); }
static Obj* prim_eq(Obj* a, Obj* b) { return mk_bool(a->i == b->i ? 1 : 0); }
static Obj* prim_cons(Obj* a, Obj* b) { inc_ref(a); inc_ref(b); return mk_cell(a, b); }
static Obj* prim_car(Obj* lst) { return is_nil(lst) ? NIL : car(lst); }
static Obj* prim_cdr(Obj* lst) { return is_nil(lst) ? NIL : cdr(lst); }
static Obj* prim_null(Obj* o) { return mk_bool(is_nil(o) ? 1 : 0); }
static int is_truthy(Obj* o) {
    if (!o) return 0;
    if (o == NOTHING) return 0;
    if (o->tag == T_SYM && o->s && strcmp(o->s, "false") == 0) return 0;
    return 1;
}

int main(void) {
    {
        Obj* _result = ({
            Obj* o_x = mk_int(1);
            (omni_print(o_x), NOTHING);
        });
        omni_print(_result);
        printf("\n");
        free_obj(_result);
    }
    return 0;
}
