module main;

import std::io;
import lisp;

extern fn int system(char* command) @extern("system");

/**
 * AOT build: compile Lisp source to standalone binary.
 * Usage: ./main --build input.lisp -o output_binary
 */
fn int run_build(int argc, char** argv, int build_idx) {
    char* input_file = null;
    char* output_binary = null;

    // Parse: --build input.lisp [-o output]
    if (build_idx + 1 < argc) {
        input_file = argv[build_idx + 1];
    }
    for (int i = build_idx + 2; i < argc; i++) {
        if (str_eq(argv[i], "-o") && i + 1 < argc) {
            output_binary = argv[i + 1];
            break;
        }
    }

    if (input_file == null) {
        io::printn("Usage: ./main --build input.lisp [-o output]");
        return 1;
    }

    // Default output name: strip extension, or append .out
    char[512] default_out;
    usz default_out_len = 0;
    if (output_binary == null) {
        char* p = input_file;
        usz input_len = 0;
        while (*p != 0) { input_len++; p++; }
        // Find last dot
        isz last_dot = -1;
        for (usz i = 0; i < input_len; i++) {
            if (input_file[i] == '.') last_dot = (isz)i;
        }
        if (last_dot > 0) {
            default_out_len = (usz)last_dot;
        } else {
            default_out_len = input_len;
        }
        for (usz i = 0; i < default_out_len && i < 511; i++) {
            default_out[i] = input_file[i];
        }
        default_out[default_out_len] = 0;
        output_binary = &default_out[0];
    }

    // Read input file
    usz input_path_len = 0;
    char* ip = input_file;
    while (*ip != 0) { input_path_len++; ip++; }
    char[] input_path = input_file[:input_path_len];

    char[] source;
    if (try s = io::file::load_temp((String)input_path)) {
        source = s;
    } else {
        io::printfn("Error: cannot read input file '%s'", (ZString)input_file);
        return 1;
    }

    // Step 1: Compile Lisp → C3
    io::printfn("Compiling %s...", (ZString)input_file);
    thread_registry_init();
    lisp::Interp* interp = (lisp::Interp*)mem::malloc(lisp::Interp.sizeof);
    interp.init();

    char[] c3_code = lisp::compile_to_c3(source, interp);

    // Step 2: Write temp C3 file
    char[] temp_path = "build/_aot_temp.c3";
    if (try file = io::file::open((String)temp_path, "w")) {
        defer (void)file.close();
        file.write(c3_code)!!;
    } else {
        io::printn("Error: cannot write temp file build/_aot_temp.c3");
        mem::free(interp);
        thread_registry_shutdown();
        return 1;
    }

    // Step 3: Invoke c3c to compile
    io::printfn("Building %s...", (ZString)output_binary);

    // Build the c3c command
    usz out_len = 0;
    char* op = output_binary;
    while (*op != 0) { out_len++; op++; }

    char[1024] cmd_buf;
    usz cmd_len = 0;
    // Standalone AOT: only 5 source files, no interpreter/JIT/replxx/lightning
    char[] prefix = "env -u LD_LIBRARY_PATH c3c compile src/main.c3 src/continuation.c3 src/ghost_index.c3 src/lisp/runtime.c3 build/_aot_temp.c3 -l dl -l m -L /usr/local/lib -o ";
    for (usz i = 0; i < prefix.len && cmd_len < 1023; i++) {
        cmd_buf[cmd_len] = prefix[i];
        cmd_len++;
    }
    for (usz i = 0; i < out_len && cmd_len < 1023; i++) {
        cmd_buf[cmd_len] = output_binary[i];
        cmd_len++;
    }
    cmd_buf[cmd_len] = 0;

    int exit_code = system(&cmd_buf[0]);

    mem::free(interp);
    thread_registry_shutdown();

    if (exit_code != 0) {
        io::printn("Error: c3c compilation failed");
        return 1;
    }

    io::printfn("Built: %s", (ZString)output_binary);
    return 0;
}

extern fn int mkdir(char* path, uint mode) @extern("mkdir");

/**
 * Scaffold a new Omni project directory.
 * Usage: ./main --init myproject
 */
fn int run_init(int argc, char** argv, int init_idx) {
    if (init_idx + 1 >= argc) {
        io::printn("Usage: ./main --init <project-name>");
        return 1;
    }
    char* name = argv[init_idx + 1];
    usz name_len = 0;
    char* np = name;
    while (*np != 0) { name_len++; np++; }

    // Create directories: name/, name/src/, name/lib/, name/lib/ffi/, name/include/
    char[512] path_buf;
    usz plen;

    // Helper: build path_buf = base + "/" + suffix, null-terminate
    // name/
    for (usz i = 0; i < name_len && i < 500; i++) path_buf[i] = name[i];
    path_buf[name_len] = 0;
    mkdir(&path_buf[0], 0o755);

    // name/src/
    plen = name_len;
    path_buf[plen] = '/'; plen++;
    char[] sub_src = "src";
    for (usz i = 0; i < sub_src.len; i++) { path_buf[plen] = sub_src[i]; plen++; }
    path_buf[plen] = 0;
    mkdir(&path_buf[0], 0o755);

    // name/lib/
    plen = name_len;
    path_buf[plen] = '/'; plen++;
    char[] sub_lib = "lib";
    for (usz i = 0; i < sub_lib.len; i++) { path_buf[plen] = sub_lib[i]; plen++; }
    path_buf[plen] = 0;
    mkdir(&path_buf[0], 0o755);

    // name/lib/ffi/
    char[] sub_ffi = "/ffi";
    for (usz i = 0; i < sub_ffi.len; i++) { path_buf[plen] = sub_ffi[i]; plen++; }
    path_buf[plen] = 0;
    mkdir(&path_buf[0], 0o755);

    // name/include/
    plen = name_len;
    path_buf[plen] = '/'; plen++;
    char[] sub_inc = "include";
    for (usz i = 0; i < sub_inc.len; i++) { path_buf[plen] = sub_inc[i]; plen++; }
    path_buf[plen] = 0;
    mkdir(&path_buf[0], 0o755);

    // name/build/
    plen = name_len;
    path_buf[plen] = '/'; plen++;
    char[] sub_build = "build";
    for (usz i = 0; i < sub_build.len; i++) { path_buf[plen] = sub_build[i]; plen++; }
    path_buf[plen] = 0;
    mkdir(&path_buf[0], 0o755);

    // Write omni.toml
    plen = name_len;
    path_buf[plen] = '/'; plen++;
    char[] toml_name = "omni.toml";
    for (usz i = 0; i < toml_name.len; i++) { path_buf[plen] = toml_name[i]; plen++; }
    path_buf[plen] = 0;
    if (try file = io::file::open((String)path_buf[:plen], "w")) {
        defer (void)file.close();
        file.write("[project]\n")!!;
        file.write("name = \"")!!;
        file.write(name[:name_len])!!;
        file.write("\"\nversion = \"0.1.5\"\n\n")!!;
        file.write("[build]\n")!!;
        file.write("output-dir = \"build\"\n")!!;
        file.write("safety = \"safe\"        # \"safe\", \"fast\", or \"none\"\n")!!;
        file.write("opt = \"O0\"             # \"O0\", \"O1\", \"O2\", \"O3\", \"Os\", \"Oz\"\n")!!;
        file.write("debug-info = \"full\"    # \"full\", \"line-tables\", \"none\"\n")!!;
        file.write("# sanitize = \"none\"    # \"none\", \"address\", \"memory\", \"thread\"\n")!!;
        file.write("# single-module = false\n\n")!!;
        file.write("# FFI dependencies — uncomment and edit:\n")!!;
        file.write("# [dependencies.ffi.math]\n")!!;
        file.write("# library = \"m\"\n")!!;
        file.write("# headers = [\"/usr/include/math.h\"]\n")!!;
        file.write("# functions = [\"sin\", \"cos\", \"sqrt\"]\n")!!;
    }

    // Write build/project.json (C3 build config — generated, do not edit)
    plen = name_len;
    path_buf[plen] = '/'; plen++;
    char[] json_path = "build/project.json";
    for (usz i = 0; i < json_path.len; i++) { path_buf[plen] = json_path[i]; plen++; }
    path_buf[plen] = 0;
    if (try file = io::file::open((String)path_buf[:plen], "w")) {
        defer (void)file.close();
        file.write("// Generated from omni.toml — do not edit\n")!!;
        file.write("{\n")!!;
        file.write("    \"langrev\": \"1\",\n")!!;
        file.write("    \"version\": \"0.1.5\",\n")!!;
        file.write("    \"sources\": [\"../src\"],\n")!!;
        file.write("    \"output\": \".\",\n")!!;
        file.write("    \"safe\": true,\n")!!;
        file.write("    \"opt\": \"O0\",\n")!!;
        file.write("    \"debug-info\": \"full\",\n")!!;
        file.write("    \"targets\": {\n")!!;
        file.write("        \"main\": {\n")!!;
        file.write("            \"type\": \"executable\"\n")!!;
        file.write("        }\n")!!;
        file.write("    }\n")!!;
        file.write("}\n")!!;
    }

    // Write src/main.omni
    plen = name_len;
    path_buf[plen] = '/'; plen++;
    char[] main_path = "src/main.omni";
    for (usz i = 0; i < main_path.len; i++) { path_buf[plen] = main_path[i]; plen++; }
    path_buf[plen] = 0;
    if (try file = io::file::open((String)path_buf[:plen], "w")) {
        defer (void)file.close();
        file.write("(println \"Hello from ")!!;
        file.write(name[:name_len])!!;
        file.write("!\")\n")!!;
    }

    io::printfn("Created project '%s'", (ZString)name);
    io::printn("");
    io::printfn("  %s/", (ZString)name);
    io::printn("    omni.toml       # Project config");
    io::printn("    src/main.omni   # Entry point");
    io::printn("    lib/ffi/        # Auto-generated FFI bindings");
    io::printn("    include/        # C headers");
    io::printn("    build/          # Build artifacts (contains project.json for c3c)");
    io::printn("");
    io::printn("Next steps:");
    io::printfn("  cd %s", (ZString)name);
    io::printn("  # Edit omni.toml to configure build and add FFI dependencies");
    io::printn("  # Run: omni --bind to generate bindings");
    return 0;
}

/**
 * Generate FFI bindings from omni.toml using libclang.
 * Usage: ./main --bind [project-dir]
 */
fn int run_bind(int argc, char** argv, int bind_idx) {
    // Determine project directory (next arg or ".")
    char[512] proj_dir;
    usz proj_dir_len;
    if (bind_idx + 1 < argc) {
        char* dir = argv[bind_idx + 1];
        proj_dir_len = 0;
        while (dir[proj_dir_len] != 0 && proj_dir_len < 510) {
            proj_dir[proj_dir_len] = dir[proj_dir_len];
            proj_dir_len++;
        }
        // Strip trailing slash
        if (proj_dir_len > 0 && proj_dir[proj_dir_len - 1] == '/') proj_dir_len--;
        proj_dir[proj_dir_len] = 0;
    } else {
        proj_dir[0] = '.';
        proj_dir[1] = 0;
        proj_dir_len = 1;
    }

    // Load omni.toml
    char[512] toml_path;
    usz tlen = 0;
    for (usz i = 0; i < proj_dir_len; i++) { toml_path[tlen] = proj_dir[i]; tlen++; }
    toml_path[tlen] = '/'; tlen++;
    char[] toml_suffix = "omni.toml";
    for (usz i = 0; i < toml_suffix.len; i++) { toml_path[tlen] = toml_suffix[i]; tlen++; }
    toml_path[tlen] = 0;

    lisp::TomlConfig* config = (lisp::TomlConfig*)mem::malloc(lisp::TomlConfig.sizeof);
    defer mem::free(config);

    if (!lisp::toml_load(toml_path[:tlen], config)) {
        io::printfn("Error: cannot read %s", (ZString)&toml_path[0]);
        return 1;
    }

    if (config.ffi_dep_count == 0) {
        io::printn("No FFI dependencies found in omni.toml");
        io::printn("Add a [dependencies.ffi.NAME] section to generate bindings.");
        return 0;
    }

    // Initialize libclang
    lisp::LibclangHandle clang;
    if (!lisp::libclang_init(&clang)) {
        io::printn("Error: libclang not found.");
        io::printn("");
        io::printn("Install libclang:");
        io::printn("  Arch:   pacman -S clang");
        io::printn("  Debian: apt install libclang-dev");
        io::printn("  Fedora: dnf install clang-devel");
        return 1;
    }
    defer lisp::libclang_destroy(&clang);

    // Allocate parsed functions buffer
    const usz MAX_FUNCS = 256;
    lisp::ParsedFunc* funcs = (lisp::ParsedFunc*)mem::malloc(lisp::ParsedFunc.sizeof * MAX_FUNCS);
    defer mem::free(funcs);

    usz total_bindings = 0;
    usz total_libs = 0;

    for (usz dep_idx = 0; dep_idx < config.ffi_dep_count; dep_idx++) {
        lisp::TomlFfiDep* dep = &config.ffi_deps[dep_idx];

        // Get null-terminated name and library
        char* dep_name = &dep.name;
        char* dep_lib = &dep.library;

        io::printfn("Parsing headers for '%s' (lib%s)...", (ZString)dep_name, (ZString)dep_lib);

        usz func_count = 0;

        // Parse each header
        for (usz hi = 0; hi < dep.header_count; hi++) {
            char* header = &dep.headers[hi];
            usz hlen = 0;
            while (header[hlen] != 0) hlen++;

            usz found = lisp::parse_header(&clang, header[:hlen],
                                           &funcs[func_count], MAX_FUNCS - func_count,
                                           &dep.functions, dep.function_count, dep.filter_functions);
            func_count += found;
        }

        if (func_count == 0) {
            io::printfn("  Warning: no functions found for '%s'", (ZString)dep_name);
            continue;
        }

        // Build output path: {proj_dir}/lib/ffi/{name}.omni
        char[512] out_path;
        usz olen = 0;
        for (usz i = 0; i < proj_dir_len; i++) { out_path[olen] = proj_dir[i]; olen++; }
        char[] ffi_mid = "/lib/ffi/";
        for (usz i = 0; i < ffi_mid.len; i++) { out_path[olen] = ffi_mid[i]; olen++; }
        usz nlen = 0;
        while (dep_name[nlen] != 0) { out_path[olen] = dep_name[nlen]; olen++; nlen++; }
        char[] omni_ext = ".omni";
        for (usz i = 0; i < omni_ext.len; i++) { out_path[olen] = omni_ext[i]; olen++; }
        out_path[olen] = 0;

        // Get dep_name and dep_lib as slices
        usz dep_name_len = 0;
        while (dep_name[dep_name_len] != 0) dep_name_len++;
        usz dep_lib_len = 0;
        while (dep_lib[dep_lib_len] != 0) dep_lib_len++;

        if (lisp::generate_ffi_module(dep_name[:dep_name_len], dep_lib[:dep_lib_len],
                                       funcs, func_count, out_path[:olen])) {
            io::printfn("  Generated %s (%d functions)", (ZString)&out_path[0], (int)func_count);
            total_bindings += func_count;
            total_libs++;
        } else {
            io::printfn("  Error: failed to write %s", (ZString)&out_path[0]);
        }
    }

    io::printfn("\nGenerated %d bindings from %d libraries.", (int)total_bindings, (int)total_libs);
    return 0;
}

fn int print_help() {
    io::printn("omni 0.1.5 — A Lisp with modern semantics");
    io::printn("");
    io::printn("Usage: omni [options] [script.omni]");
    io::printn("");
    io::printn("Running:");
    io::printn("  omni                              Start the REPL");
    io::printn("  omni <script.omni>                Run a script file");
    io::printn("  omni --repl                       Start the REPL (explicit)");
    io::printn("");
    io::printn("Building:");
    io::printn("  omni --build <file> [-o output]   AOT compile to standalone binary");
    io::printn("  omni --compile <file> <out.c3>    Compile Omni source to C3");
    io::printn("");
    io::printn("Project management:");
    io::printn("  omni --init <name>                Scaffold a new Omni project");
    io::printn("  omni --bind [project-dir]         Generate FFI bindings from omni.toml");
    io::printn("");
    io::printn("Other:");
    io::printn("  omni --gen-e2e                    Generate end-to-end compiler tests");
    io::printn("  omni --version, -v                Print version");
    io::printn("  omni --help, -h                   Print this help");
    return 0;
}

/** Main entry point. */
fn int main(int argc, char** argv) {
    // Check for --help / -h flag
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "--help") || str_eq(argv[i], "-h") || str_eq(argv[i], "-help")) {
            return print_help();
        }
    }

    // Check for --version / -v flag
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "--version") || str_eq(argv[i], "-v")) {
            io::printn("omni 0.1.5");
            return 0;
        }
    }

    // Check for --init flag (scaffold new project)
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "--init")) {
            return run_init(argc, argv, i);
        }
    }

    // Check for --bind flag (generate FFI bindings)
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "--bind")) {
            return run_bind(argc, argv, i);
        }
    }

    // Check for --build flag (AOT compile to standalone binary)
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "--build")) {
            return run_build(argc, argv, i);
        }
    }

    // Check for compile flag
    bool run_compile = false;
    char* input_file = null;
    char* output_file = null;
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "--compile") || str_eq(argv[i], "-compile")) {
            run_compile = true;
            if (i + 1 < argc) {
                input_file = argv[i + 1];
            }
            if (i + 2 < argc) {
                output_file = argv[i + 2];
            }
            break;
        }
    }

    if (run_compile) {
        // Compile mode
        if (input_file == null || output_file == null) {
            io::printn("Usage: ./main --compile input.lisp output.c3");
            return 1;
        }

        io::printfn("Compiling %s to %s...", (ZString)input_file, (ZString)output_file);

        // Read input file
        char[] input_path;
        usz input_len = 0;
        char* p = input_file;
        while (*p != 0) { input_len++; p++; }
        input_path = input_file[:input_len];

        if (try source = io::file::load_temp((String)input_path)) {
            // Initialize thread-local registry before interpreter
            thread_registry_init();

            // Initialize interpreter for symbol table (heap-allocated due to size)
            lisp::Interp* interp = (lisp::Interp*)mem::malloc(lisp::Interp.sizeof);
            interp.init();

            // Compile to C3
            char[] c3_code = lisp::compile_to_c3(source, interp);

            // Write output file
            char[] output_path;
            usz output_len = 0;
            p = output_file;
            while (*p != 0) { output_len++; p++; }
            output_path = output_file[:output_len];

            if (try file = io::file::open((String)output_path, "w")) {
                defer (void)file.close();
                file.write(c3_code)!!;
                io::printfn("Compilation successful: %s", (ZString)output_file);
                mem::free(interp);
                thread_registry_shutdown();
                return 0;
            } else {
                io::printfn("Error: cannot write output file %s", (ZString)output_file);
                mem::free(interp);
                thread_registry_shutdown();
                return 1;
            }
        } else {
            io::printfn("Error: cannot read input file %s", (ZString)input_file);
            return 1;
        }
    }

    // Check for --gen-e2e flag
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "--gen-e2e")) {
            thread_registry_init();
            lisp::Interp* interp = (lisp::Interp*)mem::malloc(lisp::Interp.sizeof);
            interp.init();
            lisp::register_primitives(interp);

            lisp::register_stdlib(interp);
            interp.flags.jit_enabled = true;

            lisp::generate_e2e_tests(interp);

            mem::free(interp);
            thread_registry_shutdown();
            return 0;
        }
    }

    // Check for REPL flag
    bool run_repl = false;
    for (int i = 1; i < argc; i++) {
        if (str_eq(argv[i], "-repl") || str_eq(argv[i], "--repl")) {
            run_repl = true;
            break;
        }
    }

    if (run_repl) {
        // Start REPL mode
        io::printn("Starting Lisp REPL...");

        // Initialize thread-local registry first
        thread_registry_init();

        // Initialize interpreter
        lisp::Interp* interp = (lisp::Interp*)mem::malloc(lisp::Interp.sizeof);
        interp.init();
        lisp::register_primitives(interp);
        lisp::register_stdlib(interp);
        interp.flags.jit_enabled = true;

        // Run REPL
        lisp::repl(interp);

        // Clean up
        mem::free(interp);
        thread_registry_shutdown();
        return 0;
    }

    // Check for script file argument (any arg that isn't a known flag)
    if (argc > 1) {
        // argv[1] is not --compile, -repl, or --repl — treat as script file
        char* script_file = argv[1];
        usz script_path_len = 0;
        char* sp = script_file;
        while (*sp != 0) { script_path_len++; sp++; }
        char[] script_path = script_file[:script_path_len];

        // Read script file
        if (try source = io::file::load_temp((String)script_path)) {
            // Initialize thread-local registry
            thread_registry_init();

            // Initialize interpreter
            lisp::Interp* interp = (lisp::Interp*)mem::malloc(lisp::Interp.sizeof);
            interp.init();
            lisp::register_primitives(interp);

            lisp::register_stdlib(interp);
            interp.flags.jit_enabled = true;

            // Push script directory for relative import resolution
            lisp::push_source_dir(script_path, interp);

            // Run the script (multiple expressions)
            usz len = source.len;
            if (len > 65535) len = 65535;
            char[] src = source[:len];
            lisp::EvalResult r = lisp::run_program(src, interp);

            if (r.error.has_error) {
                // Print error
                usz msg_len = 0;
                while (msg_len < 256 && r.error.message[msg_len] != 0) {
                    msg_len++;
                }
                if (r.error.line > 0) {
                    io::printf("Error at line %d, column %d: ", (int)r.error.line, (int)r.error.column);
                } else {
                    io::print("Error: ");
                }
                for (usz i = 0; i < msg_len; i++) {
                    io::printf("%c", r.error.message[i]);
                }
                io::printn("");
                mem::free(interp);
                thread_registry_shutdown();
                return 1;
            }

            // Print result if non-nil
            if (r.value != null && !lisp::is_nil(r.value)) {
                lisp::print_value(r.value, &interp.symbols);
                io::printn("");
            }

            mem::free(interp);
            thread_registry_shutdown();
            return 0;
        } else {
            io::printfn("Error: cannot read script file '%s'", (ZString)script_file);
            return 1;
        }
    }

    // Run tests mode
    io::printfn("Region Memory System v3 initialized");

    // Run stack engine tests (mmap stacks, context switch, coroutine lifecycle)
    run_stack_engine_tests();

    // Run scope region tests (bump allocator, RC, freelist recycling)
    run_scope_region_tests();

    // Initialize thread-local registry BEFORE Lisp tests (interpreter uses regions)
    thread_registry_init();
    io::printfn("Thread-local registry initialized, root id=%d", (uint)thread_registry().root_id);

    // Run Lisp interpreter tests
    lisp::run_lisp_tests();

    thread_registry_shutdown();

    io::printfn("System ready.");
    return 0;
}
